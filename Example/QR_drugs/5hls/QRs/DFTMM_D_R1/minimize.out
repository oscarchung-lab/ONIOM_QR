          ============================================================
          |                                                          |
          |            Crystallography & NMR System (CNS)            |
          |                         CNSsolve                         |
          |                                                          |
          ============================================================
           Version: 1.3
           Status: General release
          ============================================================
           Written by: A.T.Brunger, P.D.Adams, G.M.Clore, W.L.DeLano,
                       P.Gros, R.W.Grosse-Kunstleve,J.-S.Jiang,J.M.Krahn,
                       J.Kuszewski, M.Nilges, N.S.Pannu, R.J.Read,
                       L.M.Rice, G.F.Schroeder, T.Simonson, G.L.Warren.
           Copyright (c) 1997-2010 Yale University
          ============================================================
           Running on machine: hostname unknown (x86_64/Linux,64-bit)
           Program started by: yanz
           Program started at: 12:03:19 on 27-Nov-2023
          ============================================================

 FFT3C: Using FFTPACK4.1

 CNSsolve>{DF-GAUCNS This is minimize.inp - 2018-12-21} 
 CNSsolve>{+ directory: xtal_refine +} 
 CNSsolve>{+ description: Crystallographic conjugate gradient minimization refinement +} 
 CNSsolve>{+ authors: Axel T. Brunger, and Paul D. Adams +} 
 CNSsolve>{+ copyright: Yale University +} 
 CNSsolve> 
 CNSsolve>{+ reference: A.T. Brunger, The Free R Value: a Novel Statistical 
 CNSsolve>              Quantity for Assessing the Accuracy of Crystal Structures, 
 CNSsolve>              Nature 355, 472-474 (1992) +} 
 CNSsolve>{+ reference: N.S. Pannu and R.J. Read, Improved structure refinement 
 CNSsolve>              through maximum likelihood, Acta Cryst. A52, 659-668 (1996) +} 
 CNSsolve>{+ reference: P.D. Adams, N.S. Pannu, R.J. Read and A.T. Brunger, 
 CNSsolve>              Cross-validated Maximum Likelihood Enhances Crystallographic 
 CNSsolve>              Simulated Annealing Refinement, Proc. Natl. Acad. Sci. USA 
 CNSsolve>              94, 5018-5023 (1997) +} 
 CNSsolve> 
 CNSsolve>{- Guidelines for using this file: 
 CNSsolve>   - all strings must be quoted by double-quotes 
 CNSsolve>   - logical variables (true/false) are not quoted 
 CNSsolve>   - do not remove any evaluate statements from the file 
 CNSsolve>   - the selections store1 through store8 are available for general use -} 
 CNSsolve> 
 CNSsolve>{- begin block parameter definition -} define( 
 DEFINE> 
 DEFINE>{============================ coordinates ============================} 
 DEFINE> 
 DEFINE>{* coordinate file *} 
 DEFINE>{===>} coordinate_infile="mm3.pdb"; 
 DEFINE> 
 DEFINE>{==================== molecular information ==========================} 
 DEFINE> 
 DEFINE>{* topology files *} 
 DEFINE>{===>} topology_infile_1="CNS_TOPPAR:protein.top"; 
 DEFINE>{===>} topology_infile_2="CNS_TOPPAR:dna-rna.top"; 
 DEFINE>{===>} topology_infile_3="CNS_TOPPAR:water.top"; 
 DEFINE>{===>} topology_infile_4="CNS_TOPPAR:ion.top"; 
 DEFINE>{===>} topology_infile_5="CNS_TOPPAR:carbohydrate.top"; 
 DEFINE>{===>} topology_infile_6="62G.top"; 
 DEFINE>{===>} topology_infile_7=""; 
 DEFINE>{===>} topology_infile_8=""; 
 DEFINE> 
 DEFINE>{* linkage files for linear, continuous polymers (protein, DNA, RNA) *} 
 DEFINE>{===>} link_infile_1="CNS_TOPPAR:protein.link"; 
 DEFINE>{===>} link_infile_2="CNS_TOPPAR:dna-rna-pho.link"; 
 DEFINE>{===>} link_infile_3=""; 
 DEFINE> 
 DEFINE>{* parameter files *} 
 DEFINE>{===>} parameter_infile_1="CNS_TOPPAR:protein_rep.param"; 
 DEFINE>{===>} parameter_infile_2="CNS_TOPPAR:dna-rna_rep.param"; 
 DEFINE>{===>} parameter_infile_3="CNS_TOPPAR:water_rep.param"; 
 DEFINE>{===>} parameter_infile_4="CNS_TOPPAR:ion.param"; 
 DEFINE>{===>} parameter_infile_5="CNS_TOPPAR:carbohydrate.param"; 
 DEFINE>{===>} parameter_infile_6="62G.par"; 
 DEFINE>{===>} parameter_infile_7=""; 
 DEFINE>{===>} parameter_infile_8=""; 
 DEFINE> 
 DEFINE>{* molecular topology file: optional (leave blank for auto generation) *} 
 DEFINE>{* 
 DEFINE>   Auto generation of the molecular topology from the coordinates should only 
 DEFINE>   be used if: 
 DEFINE>   (1) Each distinct protein, DNA, or RNA chain must have a separate segid 
 DEFINE>       (or chainid if the chainid is non-blank). 
 DEFINE>   (2) Each contiguous protein, RNA, or RNA chain must not be disrupted by 
 DEFINE>       other types of residues or ligands.  Rather, these other residues 
 DEFINE>       should be listed after protein, RNA/DNA chains. 
 DEFINE>   (3) Disulphides are automatically detected based on distances between the sulfur atoms 
 DEFINE>      (must be less than 3 A apart). 
 DEFINE>   (4) Broken protein/RNA/DNA chains without terminii must be more than 2.5 A apart to be recognized as such. 
 DEFINE>   (5) N-linked glycan links are automatically recognized if the bonded atoms are less than 2.5 A apart. 
 DEFINE>   (6) Automatic generation cannot be used with alternate conformations. 
 DEFINE>   For ligands, the user must make suitable topology and parameter files. 
 DEFINE>   For non-standard covalent linkages, the custom patch file should be used. 
 DEFINE>   Alternatively, the generate.inp or generate_easy.inp task files 
 DEFINE>   can be used to generated the mtf prior to running this task file. 
 DEFINE>    *} 
 DEFINE>{===>} structure_infile="mm3.mtf"; 
 DEFINE> 
 DEFINE>{* for auto generation: extra linkages and modifications by custom patches *} 
 DEFINE>{===>} patch_infile=""; 
 DEFINE> 
 DEFINE>{* force field settings file *} 
 DEFINE>{===>} force_field_infile=""; 
 DEFINE> 
 DEFINE>{====================== crystallographic data ========================} 
 DEFINE> 
 DEFINE>{* space group *} 
 DEFINE>{* use International Table conventions with subscripts substituted 
 DEFINE>   by parenthesis *} 
 DEFINE>{===>} sg="P2(1)2(1)2(1)"; 
 DEFINE> 
 DEFINE>{* unit cell parameters in Angstroms and degrees *} 
 DEFINE>{+ table: rows=1 "cell" cols=6 "a" "b" "c" "alpha" "beta" "gamma" +} 
 DEFINE>{===>} a=33.788; 
 DEFINE>{===>} b=47.634; 
 DEFINE>{===>} c=77.775; 
 DEFINE>{===>} alpha=90.00; 
 DEFINE>{===>} beta=90.00; 
 DEFINE>{===>} gamma=90.00; 
 DEFINE> 
 DEFINE>{* anomalous f' f'' library file *} 
 DEFINE>{* If a file is not specified, no anomalous contribution will be included *} 
 DEFINE>{+ choice: "CNS_XRAYLIB:anom_cu.lib" "CNS_XRAYLIB:anom_mo.lib" "" user_file +} 
 DEFINE>{===>} anom_library=""; 
 DEFINE> 
 DEFINE>{* reflection files *} 
 DEFINE>{* specify non-anomalous reflection files before anomalous reflection files. *} 
 DEFINE>{* files must contain unique array names otherwise errors will occur *} 
 DEFINE>{===>} reflection_infile_1="5hls-sf.cv"; 
 DEFINE>{===>} reflection_infile_2=""; 
 DEFINE>{===>} reflection_infile_3=""; 
 DEFINE>{===>} reflection_infile_4=""; 
 DEFINE> 
 DEFINE>{* reciprocal space array containing observed amplitudes: required *} 
 DEFINE>{===>} obs_f="fobs"; 
 DEFINE> 
 DEFINE>{* reciprocal space array containing sigma values for amplitudes: required *} 
 DEFINE>{===>} obs_sigf="sigma"; 
 DEFINE> 
 DEFINE>{* reciprocal space array containing test set for cross-validation: required *} 
 DEFINE>{* cross-validation should always be used, with the possible exception 
 DEFINE>   of a final round of refinement including all data *} 
 DEFINE>{* cross-validation is always required for the maximum likelihood targets *} 
 DEFINE>{===>} test_set="test"; 
 DEFINE> 
 DEFINE>{* number for selection of test reflections: required for cross-validation *} 
 DEFINE>{* ie. reflections with the test set array equal to this number will be 
 DEFINE>       used for cross-validation, all other reflections form the working set *} 
 DEFINE>{===>} test_flag=1; 
 DEFINE> 
 DEFINE>{* reciprocal space array containing weighting scheme for observed 
 DEFINE>   amplitudes: optional *} 
 DEFINE>{* only used for the "residual" and "vector" targets - this will 
 DEFINE>   default to a constant value of 1 if array is not present *} 
 DEFINE>{===>} obs_w=""; 
 DEFINE> 
 DEFINE>{* reciprocal space array containing observed intensities: optional *} 
 DEFINE>{* required for the "mli" target *} 
 DEFINE>{===>} obs_i=""; 
 DEFINE> 
 DEFINE>{* reciprocal space array containing sigma values for intensities: optional *} 
 DEFINE>{* required for the "mli" target *} 
 DEFINE>{===>} obs_sigi=""; 
 DEFINE> 
 DEFINE>{* reciprocal space arrays with experimental phase probability 
 DEFINE>   distribution: optional *} 
 DEFINE>{* Hendrickson-Lattman coefficients A,B,C,D *} 
 DEFINE>{* required for the "mlhl" target *} 
 DEFINE>{+ table: rows=1 "HL coefficients" cols=4 "A" "B" "C" "D" +} 
 DEFINE>{===>} obs_pa=""; 
 DEFINE>{===>} obs_pb=""; 
 DEFINE>{===>} obs_pc=""; 
 DEFINE>{===>} obs_pd=""; 
 DEFINE> 
 DEFINE>{* complex reciprocal space array containing experimental phases: optional *} 
 DEFINE>{* required for the "mixed" and "vector" targets *} 
 DEFINE>{===>} obs_phase=""; 
 DEFINE> 
 DEFINE>{* reciprocal space array containing experimental figures of merit: optional *} 
 DEFINE>{* required for the "mixed" target *} 
 DEFINE>{===>} obs_fom=""; 
 DEFINE> 
 DEFINE>{* resolution limits to be used in refinement *} 
 DEFINE>{* the full resolution range of observed data should be used in refinement. 
 DEFINE>   A bulk solvent correction should be applied to allow the use of low 
 DEFINE>   resolution terms. If no bulk solvent correction is applied, data must 
 DEFINE>   be truncated at a lower resolution limit of between 8 and 6 Angstrom. *} 
 DEFINE>{+ table: rows=1 "resolution" cols=2 "lowest" "highest" +} 
 DEFINE>{===>} low_res=40.62; 
 DEFINE>{===>} high_res=2.18; 
 DEFINE> 
 DEFINE>{* apply rejection criteria to amplitudes or intensities *} 
 DEFINE>{+ choice: "amplitude" "intensity" +} 
 DEFINE>{===>} obs_type="amplitude"; 
 DEFINE> 
 DEFINE>{* Observed data cutoff criteria: applied to amplitudes or intensities *} 
 DEFINE>{* reflections with magnitude(Obs)/sigma < cutoff are rejected. *} 
 DEFINE>{===>} sigma_cut=0.0; 
 DEFINE> 
 DEFINE>{* rms outlier cutoff: applied to amplitudes or intensities *} 
 DEFINE>{* reflections with magnitude(Obs) > cutoff*rms(Obs) will be rejected *} 
 DEFINE>{===>} obs_rms=10000; 
 DEFINE> 
 DEFINE>{=================== non-crystallographic symmetry ===================} 
 DEFINE> 
 DEFINE>{* NCS-restraints/constraints file *} 
 DEFINE>{* see auxiliary/ncs.def *} 
 DEFINE>{===>} ncs_infile=""; 
 DEFINE> 
 DEFINE>{============ overall B-factor and bulk solvent corrections ==========} 
 DEFINE> 
 DEFINE>{* overall B-factor correction *} 
 DEFINE>{+ choice: "no" "isotropic" "anisotropic" +} 
 DEFINE>{===>} bscale="isotropic"; 
 DEFINE> 
 DEFINE>{* bulk solvent correction *} 
 DEFINE>{* a mask is required around the molecule(s). The region 
 DEFINE>   outside this mask is the solvent region *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} bulk_sol=true; 
 DEFINE> 
 DEFINE>{* bulk solvent mask file *} 
 DEFINE>{* mask will be read from O type mask file if a name is given 
 DEFINE>   otherwise calculated from coordinates of selected atoms *} 
 DEFINE>{===>} bulk_mask_infile=""; 
 DEFINE> 
 DEFINE>{* automatic bulk solvent parameter optimization for e-density level sol_k (e/A^3) and B-factor sol_b (A^2) *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} sol_auto=true; 
 DEFINE> 
 DEFINE>{* fixed solvent parameters (used if the automatic option is turned off) *} 
 DEFINE>{+ table: rows=1 "bulk solvent" cols=2 "e-density level sol_k (e/A^3)" "B-factor sol_b (A^2) " +} 
 DEFINE>{===>} sol_k=0.3; 
 DEFINE>{===>} sol_b=50.0; 
 DEFINE> 
 DEFINE>{* optional file with a listing of the results of the automatic bulk solvent optimization *} 
 DEFINE>{===>} sol_output=""; 
 DEFINE> 
 DEFINE>{* solvent mask parameters *} 
 DEFINE>{+ table: rows=1 "bulk solvent" cols=2 "probe radius (A) (usually set to 1)" "shrink radius (A) (usually set to 1)" +} 
 DEFINE>{===>} sol_rad=1.0; 
 DEFINE>{===>} sol_shrink=1.0; 
 DEFINE> 
 DEFINE>{========================== atom selection ===========================} 
 DEFINE> 
 DEFINE>{* select atoms to be included in refinement *} 
 DEFINE>{* this should include all conformations if multiple conformations are used *} 
 DEFINE>{===>} atom_select=(known and not hydrogen); 
 DEFINE> 
 DEFINE>{* select fixed atoms *} 
 DEFINE>{* note: atoms at special positions are automatically fixed. So, 
 DEFINE>   you don't have to explicitly fix them here. *} 
 DEFINE>{===>} atom_fixed=(none); 
 DEFINE> 
 DEFINE>{* select atoms to be harmonically restrained during refinement *} 
 DEFINE>{===>} atom_harm=(none); 
 DEFINE> 
 DEFINE>{* harmonic restraint constant - for harmonically restrained atoms *} 
 DEFINE>{===>} k_harmonic=10; 
 DEFINE> 
 DEFINE>{* select atoms in alternate conformation 1 *} 
 DEFINE>{===>} conf_1=(none); 
 DEFINE> 
 DEFINE>{* select atoms in alternate conformation 2 *} 
 DEFINE>{===>} conf_2=(none); 
 DEFINE> 
 DEFINE>{* select atoms in alternate conformation 3 *} 
 DEFINE>{===>} conf_3=(none); 
 DEFINE> 
 DEFINE>{* select atoms in alternate conformation 4 *} 
 DEFINE>{===>} conf_4=(none); 
 DEFINE> 
 DEFINE>{* additional restraints file *} 
 DEFINE>{* eg. auxiliary/dna-rna_restraints.def *} 
 DEFINE>{===>} restraints_infile=""; 
 DEFINE> 
 DEFINE>{===================== minimization parameters =======================} 
 DEFINE> 
 DEFINE>{* number of minimization steps *} 
 DEFINE>{===>} minimize_nstep=0; 
 DEFINE> 
 DEFINE>{* number of cycles *} 
 DEFINE>{===>} num_cycles=1; 
 DEFINE> 
 DEFINE>{* refinement target *} 
 DEFINE>{+ list: mlf: maximum likelihood target using amplitudes 
 DEFINE>         mli: maximum likelihood target using intensities 
 DEFINE>        mlhl: maximum likelihood target using amplitudes 
 DEFINE>              and phase probability distribution 
 DEFINE>    residual: standard crystallographic residual 
 DEFINE>      vector: vector residual 
 DEFINE>       mixed: (1-fom)*residual + fom*vector 
 DEFINE>        e2e2: correlation coefficient using normalized E^2 
 DEFINE>        e1e1: correlation coefficient using normalized E 
 DEFINE>        f2f2: correlation coefficient using F^2 
 DEFINE>        f1f1: correlation coefficient using F +} 
 DEFINE>{+ choice: "mlf" "mli" "mlhl" "residual" "vector" "mixed" 
 DEFINE>           "e2e2" "e1e1" "f2f2" "f1f1" +} 
 DEFINE>{===>} reftarget="mlf"; 
 DEFINE> 
 DEFINE>{* Wa weight for X-ray term *} 
 DEFINE>{* this will be determined automatically if a negative value is given. 
 DEFINE>   Note: wa can be very different depending on the target - if it is not 
 DEFINE>         determined automatically make sure an appropriate value is used *} 
 DEFINE>{===>} wa=1.7995; 
 DEFINE> 
 DEFINE>{* number of bins for refinement target *} 
 DEFINE>{* this will be determined automatically if a negative value is given 
 DEFINE>   otherwise the specified number of bins will be used *} 
 DEFINE>{===>} target_bins=-1; 
 DEFINE> 
 DEFINE>{* memory allocation for FFT calculation *} 
 DEFINE>{* this will be determined automatically if a negative value is given 
 DEFINE>   otherwise the specified number of words will be allocated *} 
 DEFINE>{===>} fft_memory=-1; 
 DEFINE> 
 DEFINE>{=========================== output files ============================} 
 DEFINE> 
 DEFINE>{* output coordinate file *} 
 DEFINE>{===>} coordinate_outfile="minimize.pdb"; 
 DEFINE> 
 DEFINE>{===========================================================================} 
 DEFINE>{        things below this line do not normally need to be changed          } 
 DEFINE>{===========================================================================} 
 DEFINE> 
 DEFINE> ) {- end block parameter definition -} 
 CNSsolve> 
 CNSsolve> checkversion 1.3 
 Program version= 1.3 File version= 1.3
 CNSsolve> 
 CNSsolve> evaluate ($log_level=quiet) 
 Assuming literal string "QUIET"
 EVALUATE: symbol $LOG_LEVEL set to "QUIET" (string)
 CNSsolve> 
 CNSsolve> if ( $log_level = verbose ) then 
 NEXTCD: condition evaluated as false
 CNSsolve>   set message=normal echo=on end 
 CNSsolve> else 
 CNSsolve>   set message=off echo=off end 
 REMARKS FILENAME="mm3.mtf"
 REMARKS DATE:10-Oct-2022  11:30:34       created by user: yanzy
 REMARKS VERSION:1.3
 EVALUATE: symbol $PD_X set to    1.00000     (real)
 EVALUATE: symbol $PD_V set to    13971.0     (real)
 EVALUATE: symbol $PD_V set to    19949.0     (real)
 EVALUATE: symbol $PD_V set to    19949.0     (real)
 EVALUATE: symbol $PD_V set to    13971.0     (real)
 EVALUATE: symbol $PD_V set to    19949.0     (real)
 EVALUATE: symbol $PD_V set to    8333.10     (real)
 EVALUATE: symbol $PD_V set to    19949.0     (real)
 EVALUATE: symbol $PD_V set to    13971.0     (real)
 EVALUATE: symbol $PD_V set to    19949.0     (real)
 EVALUATE: symbol $PD_V set to    13971.0     (real)
 EVALUATE: symbol $PD_V set to    19949.0     (real)
 EVALUATE: symbol $PD_V set to    19949.0     (real)
 EVALUATE: symbol $PD_V set to    20084.6     (real)
 EVALUATE: symbol $PD_V set to    19949.0     (real)
 EVALUATE: symbol $PD_V set to    15998.7     (real)
 EVALUATE: symbol $PD_V set to    19949.0     (real)
 EVALUATE: symbol $PD_V set to    19949.0     (real)
 EVALUATE: symbol $PD_V set to    13971.0     (real)
 EVALUATE: symbol $PD_V set to    19949.0     (real)
 EVALUATE: symbol $PD_V set to    13971.0     (real)
 EVALUATE: symbol $PD_V set to    19949.0     (real)
 EVALUATE: symbol $PD_V set to    13971.0     (real)
 EVALUATE: symbol $PD_V set to    19949.0     (real)
 EVALUATE: symbol $PD_V set to    13971.0     (real)
 EVALUATE: symbol $PD_V set to    19949.0     (real)
 EVALUATE: symbol $PD_V set to    19955.1     (real)
 EVALUATE: symbol $PD_V set to    19955.1     (real)
 EVALUATE: symbol $PD_V set to    19955.1     (real)
 EVALUATE: symbol $PD_V set to    16001.4     (real)
 EVALUATE: symbol $PD_V set to    19955.1     (real)
 EVALUATE: symbol $PD_V set to    13971.0     (real)
 EVALUATE: symbol $PD_V set to    13971.0     (real)
 EVALUATE: symbol $PD_V set to    13971.0     (real)
 EVALUATE: symbol $PD_V set to    4848.00     (real)
 EVALUATE: symbol $PD_V set to    6568.40     (real)
 EVALUATE: symbol $PD_V set to    15996.2     (real)
 EVALUATE: symbol $PD_V set to    13971.0     (real)
 EVALUATE: symbol $PD_V set to    16001.4     (real)
 EVALUATE: symbol $PD_V set to    13971.0     (real)
 EVALUATE: symbol $PD_V set to    13971.0     (real)
 EVALUATE: symbol $PD_V set to    16001.4     (real)
 EVALUATE: symbol $PD_V set to    24009.7     (real)
 EVALUATE: symbol $PD_V set to    17925.8     (real)
 EVALUATE: symbol $PD_V set to    17877.6     (real)
 EVALUATE: symbol $PD_V set to    17877.6     (real)
 EVALUATE: symbol $PD_V set to    724.200     (real)
 EVALUATE: symbol $PD_V set to    724.200     (real)
 EVALUATE: symbol $PD_V set to    724.200     (real)
 EVALUATE: symbol $PD_V set to    724.200     (real)
 EVALUATE: symbol $PD_V set to    724.200     (real)
 EVALUATE: symbol $PD_V set to    724.200     (real)
 EVALUATE: symbol $PD_V set to    803.100     (real)
 EVALUATE: symbol $PD_V set to    803.100     (real)
 EVALUATE: symbol $PD_V set to    803.100     (real)
 EVALUATE: symbol $PD_V set to    724.200     (real)
 EVALUATE: symbol $PD_V set to    724.200     (real)
 EVALUATE: symbol $PD_V set to    724.200     (real)
 EVALUATE: symbol $PD_V set to    724.200     (real)
 EVALUATE: symbol $PD_V set to    724.200     (real)
 EVALUATE: symbol $PD_V set to    724.200     (real)
 EVALUATE: symbol $PD_V set to    803.100     (real)
 EVALUATE: symbol $PD_V set to    803.100     (real)
 EVALUATE: symbol $PD_V set to    803.100     (real)
 EVALUATE: symbol $PD_V set to    803.100     (real)
 EVALUATE: symbol $PD_V set to    803.100     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    760.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    803.100     (real)
 EVALUATE: symbol $PD_V set to    724.200     (real)
 EVALUATE: symbol $PD_V set to    724.200     (real)
 EVALUATE: symbol $PD_V set to    724.200     (real)
 EVALUATE: symbol $PD_V set to    724.200     (real)
 EVALUATE: symbol $PD_V set to    724.200     (real)
 EVALUATE: symbol $PD_V set to    724.200     (real)
 EVALUATE: symbol $PD_V set to    724.200     (real)
 EVALUATE: symbol $PD_V set to    724.200     (real)
 EVALUATE: symbol $PD_V set to    724.200     (real)
 EVALUATE: symbol $PD_V set to    724.200     (real)
 EVALUATE: symbol $PD_V set to    724.200     (real)
 EVALUATE: symbol $PD_V set to    724.200     (real)
 EVALUATE: symbol $PD_V set to    803.100     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    760.000     (real)
 EVALUATE: symbol $PD_V set to    803.100     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    804.200     (real)
 EVALUATE: symbol $PD_V set to    803.100     (real)
 EVALUATE: symbol $PD_V set to    804.200     (real)
 EVALUATE: symbol $PD_V set to    803.100     (real)
 EVALUATE: symbol $PD_V set to    720.000     (real)
 EVALUATE: symbol $PD_V set to    720.000     (real)
 EVALUATE: symbol $PD_V set to    720.000     (real)
 EVALUATE: symbol $PD_V set to    720.000     (real)
 EVALUATE: symbol $PD_V set to    720.000     (real)
 EVALUATE: symbol $PD_V set to    720.000     (real)
 EVALUATE: symbol $PD_V set to    804.200     (real)
 EVALUATE: symbol $PD_V set to    720.000     (real)
 EVALUATE: symbol $PD_V set to    804.200     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    962.300     (real)
 EVALUATE: symbol $PD_V set to    760.000     (real)
 EVALUATE: symbol $PD_V set to    760.000     (real)
 EVALUATE: symbol $PD_V set to    883.200     (real)
 EVALUATE: symbol $PD_V set to    720.000     (real)
 EVALUATE: symbol $PD_V set to    883.500     (real)
 EVALUATE: symbol $PD_V set to    720.000     (real)
 EVALUATE: symbol $PD_V set to    720.000     (real)
 EVALUATE: symbol $PD_V set to    720.000     (real)
 EVALUATE: symbol $PD_V set to    883.500     (real)
 EVALUATE: symbol $PD_V set to    720.000     (real)
 EVALUATE: symbol $PD_V set to    720.000     (real)
 EVALUATE: symbol $PD_V set to    720.000     (real)
 EVALUATE: symbol $PD_V set to    962.300     (real)
 EVALUATE: symbol $PD_V set to    958.000     (real)
 EVALUATE: symbol $PD_V set to    959.300     (real)
 EVALUATE: symbol $PD_V set to    559.300     (real)
 EVALUATE: symbol $PD_V set to    559.300     (real)
 EVALUATE: symbol $PD_V set to    638.100     (real)
 EVALUATE: symbol $PD_V set to    80.0000     (real)
 EVALUATE: symbol $PD_V set to    80.0000     (real)
 EVALUATE: symbol $PD_V set to    80.0000     (real)
 EVALUATE: symbol $PD_V set to    80.0000     (real)
 EVALUATE: symbol $PD_V set to    80.0000     (real)
 EVALUATE: symbol $PD_V set to    80.0000     (real)
 EVALUATE: symbol $PD_V set to    80.0000     (real)
 EVALUATE: symbol $PD_V set to    80.0000     (real)
 EVALUATE: symbol $PD_V set to    80.0000     (real)
 EVALUATE: symbol $PD_V set to    80.0000     (real)
 EVALUATE: symbol $PD_V set to    80.0000     (real)
 EVALUATE: symbol $PD_V set to    80.0000     (real)
 EVALUATE: symbol $PD_V set to    80.0000     (real)
 EVALUATE: symbol $PD_V set to    80.0000     (real)
 EVALUATE: symbol $PD_V set to    80.0000     (real)
 EVALUATE: symbol $PD_V set to    160.100     (real)
 EVALUATE: symbol $PD_V set to    80.0000     (real)
 EVALUATE: symbol $PD_V set to    160.100     (real)
 EVALUATE: symbol $PD_V set to    160.100     (real)
 EVALUATE: symbol $PD_V set to    80.0000     (real)
 EVALUATE: symbol $PD_V set to    80.0000     (real)
 EVALUATE: symbol $PD_V set to    100.000     (real)
 EVALUATE: symbol $PD_V set to    100.000     (real)
 EVALUATE: symbol $PD_V set to    100.000     (real)
 EVALUATE: symbol $PD_V set to    100.000     (real)
 EVALUATE: symbol $PD_V set to    100.000     (real)
 EVALUATE: symbol $PD_V set to    100.000     (real)
 EVALUATE: symbol $PD_V set to    100.000     (real)
 EVALUATE: symbol $PD_V set to    100.000     (real)
 EVALUATE: symbol $PD_V set to    100.000     (real)
 EVALUATE: symbol $PD_V set to    100.000     (real)
 EVALUATE: symbol $PD_V set to    100.000     (real)
 EVALUATE: symbol $PD_V set to    100.000     (real)
 EVALUATE: symbol $PD_V set to    100.000     (real)
 EVALUATE: symbol $PD_V set to    100.000     (real)
 EVALUATE: symbol $PD_V set to    100.000     (real)
 EVALUATE: symbol $PD_V set to    100.000     (real)
 EVALUATE: symbol $PD_V set to    100.000     (real)
 EVALUATE: symbol $PD_V set to    19.6000     (real)
 EVALUATE: symbol $PD_V set to    641.100     (real)
 EVALUATE: symbol $PD_V set to    19.6000     (real)
 EVALUATE: symbol $PD_V set to   0.600000     (real)
 EVALUATE: symbol $PD_V set to    19.6000     (real)
 EVALUATE: symbol $PD_V set to   0.600000     (real)
 EVALUATE: symbol $PD_V set to   0.600000     (real)
 EVALUATE: symbol $PD_V set to    19.6000     (real)
 EVALUATE: symbol $PD_V set to   0.600000     (real)
 EVALUATE: symbol $PD_V set to    641.100     (real)
 PARRDR>      end if 
 PARRDR>   else 
 PARRDR>     evaluate ($done=true) 
 PARRDR>   end if 
 PARRDR>   evaluate ($counter=$counter+1) 
 EVALUATE: symbol $COUNTER set to    7.00000     (real)
 PARRDR>  end loop read 
 PARRDR>  while ( $done = false ) loop read 
 NEXTCD: condition evaluated as true
 PARRDR>   if ( &exist_parameter_infile_$counter = true ) then 
 NEXTCD: condition evaluated as true
 PARRDR>      if ( &BLANK%parameter_infile_$counter = false ) then 
 NEXTCD: condition evaluated as false
 PARRDR>         @@&parameter_infile_$counter 
 PARRDR>      end if 
 PARRDR>   else 
 PARRDR>     evaluate ($done=true) 
 PARRDR>   end if 
 PARRDR>   evaluate ($counter=$counter+1) 
 EVALUATE: symbol $COUNTER set to    8.00000     (real)
 PARRDR>  end loop read 
 PARRDR>  while ( $done = false ) loop read 
 NEXTCD: condition evaluated as true
 PARRDR>   if ( &exist_parameter_infile_$counter = true ) then 
 NEXTCD: condition evaluated as true
 PARRDR>      if ( &BLANK%parameter_infile_$counter = false ) then 
 NEXTCD: condition evaluated as false
 PARRDR>         @@&parameter_infile_$counter 
 PARRDR>      end if 
 PARRDR>   else 
 PARRDR>     evaluate ($done=true) 
 PARRDR>   end if 
 PARRDR>   evaluate ($counter=$counter+1) 
 EVALUATE: symbol $COUNTER set to    9.00000     (real)
 PARRDR>  end loop read 
 PARRDR>  while ( $done = false ) loop read 
 NEXTCD: condition evaluated as true
 PARRDR>   if ( &exist_parameter_infile_$counter = true ) then 
 NEXTCD: condition evaluated as false
 PARRDR>      if ( &BLANK%parameter_infile_$counter = false ) then 
 PARRDR>         @@&parameter_infile_$counter 
 PARRDR>      end if 
 PARRDR>   else 
 PARRDR>     evaluate ($done=true) 
 EVALUATE: symbol $DONE set to TRUE (logical)
 PARRDR>   end if 
 PARRDR>   evaluate ($counter=$counter+1) 
 EVALUATE: symbol $COUNTER set to    10.0000     (real)
 PARRDR>  end loop read 
 PARRDR>  while ( $done = false ) loop read 
 NEXTCD: condition evaluated as false
 PARRDR>   if ( &exist_parameter_infile_$counter = true ) then 
 PARRDR>      if ( &BLANK%parameter_infile_$counter = false ) then 
 PARRDR>         @@&parameter_infile_$counter 
 PARRDR>      end if 
 PARRDR>   else 
 PARRDR>     evaluate ($done=true) 
 PARRDR>   end if 
 PARRDR>   evaluate ($counter=$counter+1) 
 PARRDR>  end loop read 
 PARRDR> end 
 %PARRDR-info: duplication of nonbonded entry CL  
 CNSsolve> 
 CNSsolve> set message=normal echo=on end 
 CNSsolve> 
 CNSsolve> xray 
 XRAY> 
 XRAY>   @CNS_XTALLIB:spacegroup.lib (sg=&sg; 
 ASSFIL: file spacegroup.lib opened.
 XRAY>! file  libraries/xtal/spacegroup.lib 
 XRAY>! library of symmetry operators for CNS 
 XRAY>! Automatically generated with SgInfo Version 2.00a13 
 XRAY> 
 XRAY>module 
 MODULE-DECLARATION>( 
 MODULE-DECLARATION>  &sg=$sg; 
 MODULE-DECLARATION>  &sgparam=$sgparam; 
 MODULE-DECLARATION>) 
 &_2_SG set to &_1_SG 
 MODULE-INVOCATION>                                sgparam=$sgparam;) 
 &_2_SGPARAM set to $_1_SGPARAM 
 XRAY> 
 XRAY>set message ? end 
 MESSage=NORM
 XRAY>evaluate ($message_old=$result) 
 EVALUATE: symbol $MESSAGE_OLD set to "NORM" (string)
 XRAY>set echo ? end 
 ECHO=TRUE {ON}
 XRAY>evaluate ($echo_old=$result) 
 EVALUATE: symbol $ECHO_OLD set to TRUE (logical)
 XRAY>set echo=off message=off end 
SYMMETRY: found symmetry operators for space group "P2(1)2(1)2(1)" in library
 XRAY> 
 XRAY> 
 XRAY>   a=&a b=&b c=&c  alpha=&alpha beta=&beta gamma=&gamma 
 XRAY> 
 XRAY>   @CNS_XRAYLIB:scatter.lib 
 ASSFIL: file scatter.lib opened.
 XRAY>! file libraries/xray/scatter.lib 
 XRAY>! Atomic scattering factors without anomalous contribution 
 XRAY>! Library for CNS 
 XRAY> 
 XRAY>! Authors: Paul Adams, Joe Jaeger, and Axel T. Brunger 
 XRAY> 
 XRAY>!BEWARE: 
 XRAY>!(1) element Cf (Californium) has to be referred to as Cff 
 XRAY>!(2) element Sm (Samarium) has to be referred to as Smm 
 XRAY>!(3) element Np (Neptunium) has to be referred to as Npp 
 XRAY>!(3) types of elements with ionic state (i.e., +/-) specifications have 
 XRAY>!    to be put in double quotes in selection statements. 
 XRAY> 
 XRAY>set message ? end 
 MESSage=NORM
 XRAY>evaluate ($message_old_sclib=$result) 
 EVALUATE: symbol $MESSAGE_OLD_SCLIB set to "NORM" (string)
 XRAY>set echo ? end 
 ECHO=TRUE {ON}
 XRAY>evaluate ($echo_old_sclib=$result) 
 EVALUATE: symbol $ECHO_OLD_SCLIB set to TRUE (logical)
 XRAY>set echo=off message=off end 
 XRAY> 
 XRAY>   evaluate ($counter=1) 
 EVALUATE: symbol $COUNTER set to    1.00000     (real)
 XRAY>   evaluate ($done=false) 
 EVALUATE: symbol $DONE set to FALSE (logical)
 XRAY>   while ( $done = false ) loop read 
 NEXTCD: condition evaluated as true
 XRAY>    if ( &exist_reflection_infile_$counter = true ) then 
 NEXTCD: condition evaluated as true
 XRAY>      if ( &BLANK%reflection_infile_$counter = false ) then 
 NEXTCD: condition evaluated as true
 XRAY>       reflection 
 REFLection>         @@&reflection_infile_$counter 
 ASSFIL: file 5hls-sf.cv opened.
 REFLection> remark a= 33.788 b= 47.634 c= 77.775 alpha= 90 beta= 90 gamma= 90 sg= P2(1)2(1)2(1) 
 REFLection> remark symop (X,Y,Z) 
 REFLection> remark symop (-X+1/2,-Y,Z+1/2) 
 REFLection> remark symop (X+1/2,-Y+1/2,-Z) 
 REFLection> remark symop (-X,Y+1/2,-Z+1/2) 
 REFLection>CRYST1   33.788   47.634   77.775  90.00  90.00  90.00 P 21 21 21 
 REFLection> NREFlection=      6261 
 XRAY: increasing space allocation for up to    6261 reflections.
 REFLection> ANOMalous=FALSe { equiv. to HERMitian=TRUE} 
 REFLection> DECLare NAME=FOBS                   DOMAin=RECIprocal   TYPE=REAL END 
 XDECLARE: Object FOBS has been declared.
 REFLection> DECLare NAME=SIGMA                  DOMAin=RECIprocal   TYPE=REAL END 
 XDECLARE: Object SIGMA has been declared.
 REFLection> DECLare NAME=TEST                   DOMAin=RECIprocal   TYPE=INTE END 
 XDECLARE: Object TEST has been declared.
 REFLection> DECLare NAME=IOBS                   DOMAin=RECIprocal   TYPE=REAL END 
 XDECLARE: Object IOBS has been declared.
 REFLection> DECLare NAME=SIGI                   DOMAin=RECIprocal   TYPE=REAL END 
 XDECLARE: Object SIGI has been declared.
 REFLection> DECLare NAME=F+                     DOMAin=RECIprocal   TYPE=REAL END 
 %XDECLARE-ERR: Invalid name: must start with letter and no special chars.:
  DECLare NAME=F+ 
               ^^
 XDECLARE: Object F+ has been declared.
 REFLection> DECLare NAME=SIGF+                  DOMAin=RECIprocal   TYPE=REAL END 
 %XDECLARE-ERR: Invalid name: must start with letter and no special chars.:
  DECLare NAME=SIGF+ 
               ^^^^^
 XDECLARE: Object SIGF+ has been declared.
 REFLection> DECLare NAME=F-                     DOMAin=RECIprocal   TYPE=REAL END 
 %XDECLARE-ERR: Invalid name: must start with letter and no special chars.:
  DECLare NAME=F- 
               ^^
 XDECLARE: Object F- has been declared.
 REFLection> DECLare NAME=SIGF-                  DOMAin=RECIprocal   TYPE=REAL END 
 %XDECLARE-ERR: Invalid name: must start with letter and no special chars.:
  DECLare NAME=SIGF- 
               ^^^^^
 XDECLARE: Object SIGF- has been declared.
 REFLection> INDE     0    0    4 FOBS=   249.820 SIGMA=     2.290 TEST=         0 
 XSFAL: allocating space for real reciprocal space object.
 XSFAL: allocating space for real reciprocal space object.
 XSFAL: allocating space for integer reciprocal space object.
 XSFAL: allocating space for real reciprocal space object.
 XSFAL: allocating space for real reciprocal space object.
 XSFAL: allocating space for real reciprocal space object.
 XSFAL: allocating space for real reciprocal space object.
 XSFAL: allocating space for real reciprocal space object.
 XSFAL: allocating space for real reciprocal space object.
 XRRR2:     6261 new h,k,l indices have been added.
 XRAY>      end if 
 XRAY>   else 
 XRAY>     evaluate ($done=true) 
 XRAY>   end if 
 XRAY>   evaluate ($counter=$counter+1) 
 EVALUATE: symbol $COUNTER set to    2.00000     (real)
 XRAY>  end loop read 
 XRAY>   while ( $done = false ) loop read 
 NEXTCD: condition evaluated as true
 XRAY>    if ( &exist_reflection_infile_$counter = true ) then 
 NEXTCD: condition evaluated as true
 XRAY>      if ( &BLANK%reflection_infile_$counter = false ) then 
 NEXTCD: condition evaluated as false
 XRAY>       reflection 
 XRAY>         @@&reflection_infile_$counter 
 XRAY>       end 
 XRAY>      end if 
 XRAY>   else 
 XRAY>     evaluate ($done=true) 
 XRAY>   end if 
 XRAY>   evaluate ($counter=$counter+1) 
 EVALUATE: symbol $COUNTER set to    3.00000     (real)
 XRAY>  end loop read 
 XRAY>   while ( $done = false ) loop read 
 NEXTCD: condition evaluated as true
 XRAY>    if ( &exist_reflection_infile_$counter = true ) then 
 NEXTCD: condition evaluated as true
 XRAY>      if ( &BLANK%reflection_infile_$counter = false ) then 
 NEXTCD: condition evaluated as false
 XRAY>       reflection 
 XRAY>         @@&reflection_infile_$counter 
 XRAY>       end 
 XRAY>      end if 
 XRAY>   else 
 XRAY>     evaluate ($done=true) 
 XRAY>   end if 
 XRAY>   evaluate ($counter=$counter+1) 
 EVALUATE: symbol $COUNTER set to    4.00000     (real)
 XRAY>  end loop read 
 XRAY>   while ( $done = false ) loop read 
 NEXTCD: condition evaluated as true
 XRAY>    if ( &exist_reflection_infile_$counter = true ) then 
 NEXTCD: condition evaluated as true
 XRAY>      if ( &BLANK%reflection_infile_$counter = false ) then 
 NEXTCD: condition evaluated as false
 XRAY>       reflection 
 XRAY>         @@&reflection_infile_$counter 
 XRAY>       end 
 XRAY>      end if 
 XRAY>   else 
 XRAY>     evaluate ($done=true) 
 XRAY>   end if 
 XRAY>   evaluate ($counter=$counter+1) 
 EVALUATE: symbol $COUNTER set to    5.00000     (real)
 XRAY>  end loop read 
 XRAY>   while ( $done = false ) loop read 
 NEXTCD: condition evaluated as true
 XRAY>    if ( &exist_reflection_infile_$counter = true ) then 
 NEXTCD: condition evaluated as false
 XRAY>      if ( &BLANK%reflection_infile_$counter = false ) then 
 XRAY>       reflection 
 XRAY>         @@&reflection_infile_$counter 
 XRAY>       end 
 XRAY>      end if 
 XRAY>   else 
 XRAY>     evaluate ($done=true) 
 EVALUATE: symbol $DONE set to TRUE (logical)
 XRAY>   end if 
 XRAY>   evaluate ($counter=$counter+1) 
 EVALUATE: symbol $COUNTER set to    6.00000     (real)
 XRAY>  end loop read 
 XRAY>   while ( $done = false ) loop read 
 NEXTCD: condition evaluated as false
 XRAY>    if ( &exist_reflection_infile_$counter = true ) then 
 XRAY>      if ( &BLANK%reflection_infile_$counter = false ) then 
 XRAY>       reflection 
 XRAY>         @@&reflection_infile_$counter 
 XRAY>       end 
 XRAY>      end if 
 XRAY>   else 
 XRAY>     evaluate ($done=true) 
 XRAY>   end if 
 XRAY>   evaluate ($counter=$counter+1) 
 XRAY>  end loop read 
 XRAY> 
 XRAY> end 
 CNSsolve> 
 CNSsolve> if ( &BLANK%anom_library = false ) then 
 NEXTCD: condition evaluated as false
 CNSsolve>   @@&anom_library 
 CNSsolve> else 
 CNSsolve>   set echo=off end 
 ANOMalous=FALSe {OFF}
 NEXTCD: condition evaluated as false
 CNSsolve> end if 
 CNSsolve> 
 CNSsolve> {- copy define parameters of optional arrays into symbols so 
 CNSsolve>    we can redefine them -} 
 CNSsolve> 
 CNSsolve> evaluate ($obs_i=&obs_i) 
 EVALUATE: symbol $OBS_I set to "" (string)
 CNSsolve> evaluate ($obs_sigi=&obs_sigi) 
 EVALUATE: symbol $OBS_SIGI set to "" (string)
 CNSsolve> evaluate ($obs_w=&obs_w) 
 EVALUATE: symbol $OBS_W set to "" (string)
 CNSsolve> xray 
 XRAY>   @@CNS_XTALMODULE:checkrefinput ( 
 ASSFIL: file checkrefinput opened.
 XRAY>! Module file: checkrefinput 
 XRAY>! 
 XRAY>! CNS module 
 XRAY>! ********** 
 XRAY>! 
 XRAY>! Authors: Axel Brunger and Paul Adams 
 XRAY>! 
 XRAY>! copyright Yale University 
 XRAY>! 
 XRAY>! Function: 
 XRAY>!    Checks the required input reciprocal space arrays 
 XRAY>! 
 XRAY>! Requirements: 
 XRAY>!    Needs to be called within xray 
 XRAY> 
 XRAY>module {checkrefinput} 
 MODULE-DECLARATION> 
 MODULE-DECLARATION>( 
 MODULE-DECLARATION>  &reftarget="residual"; {string} 
 MODULE-DECLARATION>  &obs_f;                {reciprocal space array} 
 MODULE-DECLARATION>  &obs_sigf;             {reciprocal space array} 
 MODULE-DECLARATION>  &test_set;             {reciprocal space array} 
 MODULE-DECLARATION>  &obs_pa;               {reciprocal space array} 
 MODULE-DECLARATION>  &obs_pb;               {reciprocal space array} 
 MODULE-DECLARATION>  &obs_pc;               {reciprocal space array} 
 MODULE-DECLARATION>  &obs_pd;               {reciprocal space array} 
 MODULE-DECLARATION>  &obs_phase;            {reciprocal space array} 
 MODULE-DECLARATION>  &obs_fom;              {reciprocal space array} 
 MODULE-DECLARATION>  &obs_w;                {reciprocal space array} 
 MODULE-DECLARATION>  &obs_i;                {reciprocal space array} 
 MODULE-DECLARATION>  &obs_sigi;             {reciprocal space array} 
 MODULE-DECLARATION>) 
 MODULE-INVOCATION>                                  reftarget=&reftarget; 
 &_2_REFTARGET set to &_1_REFTARGET 
 MODULE-INVOCATION>                                  obs_f=&obs_f; 
 &_2_OBS_F set to &_1_OBS_F 
 MODULE-INVOCATION>                                  obs_sigf=&obs_sigf; 
 &_2_OBS_SIGF set to &_1_OBS_SIGF 
 MODULE-INVOCATION>                                  test_set=&test_set; 
 &_2_TEST_SET set to &_1_TEST_SET 
 MODULE-INVOCATION>                                  obs_pa=&obs_pa; 
 &_2_OBS_PA set to &_1_OBS_PA 
 MODULE-INVOCATION>                                  obs_pb=&obs_pb; 
 &_2_OBS_PB set to &_1_OBS_PB 
 MODULE-INVOCATION>                                  obs_pc=&obs_pc; 
 &_2_OBS_PC set to &_1_OBS_PC 
 MODULE-INVOCATION>                                  obs_pd=&obs_pd; 
 &_2_OBS_PD set to &_1_OBS_PD 
 MODULE-INVOCATION>                                  obs_phase=&obs_phase; 
 &_2_OBS_PHASE set to &_1_OBS_PHASE 
 MODULE-INVOCATION>                                  obs_fom=&obs_fom; 
 &_2_OBS_FOM set to &_1_OBS_FOM 
 MODULE-INVOCATION>                                  obs_w=$obs_w; 
 &_2_OBS_W set to $_1_OBS_W 
 MODULE-INVOCATION>                                  obs_i=$obs_i; 
 &_2_OBS_I set to $_1_OBS_I 
 MODULE-INVOCATION>                                  obs_sigi=$obs_sigi; 
 &_2_OBS_SIGI set to $_1_OBS_SIGI 
 MODULE-INVOCATION>                                  ) 
 XRAY> 
 XRAY>set message ? end 
 MESSage=NORM
 XRAY>evaluate ($message_old_cri=$result) 
 EVALUATE: symbol $MESSAGE_OLD_CRI set to "NORM" (string)
 XRAY>set echo ? end 
 ECHO=TRUE {ON}
 XRAY>evaluate ($echo_old_cri=$result) 
 EVALUATE: symbol $ECHO_OLD_CRI set to TRUE (logical)
 XRAY>if ( $log_level = verbose ) then 
 NEXTCD: condition evaluated as false
 XRAY>  set echo=on message=normal end 
 XRAY>else 
 XRAY>  set echo=off message=off end 
 XRAY> 
 XRAY>   query name=fcalc domain=reciprocal end 
 Reciprocal space object FCALC does not exist.
 XRAY>   if ( $object_exist = false ) then 
 NEXTCD: condition evaluated as true
 XRAY>      declare name=fcalc domain=reciprocal type=complex end 
 XDECLARE: Object FCALC has been declared.
 XRAY>   end if 
 XRAY>   declare name=fbulk domain=reciprocal type=complex end 
 XDECLARE: Object FBULK has been declared.
 XRAY>   do (fbulk=0) ( all ) 
 XSFAL: allocating space for complex reciprocal space object.
 Total of      6261 structure factor elements were selected.
 XRAY> 
 XRAY>   binresolution &low_res &high_res 
 XRAY>   mapresolution &high_res 
 XRAY> 
 XRAY>   if ( &obs_type = "intensity" ) then 
 NEXTCD: condition evaluated as false
 XRAY>     if ( &BLANK%obs_i = true ) then 
 XRAY>       display  Error: observed intensity array is undefined 
 XRAY>       display         aborting script 
 XRAY>       abort 
 XRAY>     end if 
 XRAY>     evaluate ($reject_obs=&obs_i) 
 XRAY>     evaluate ($reject_sig=&obs_sigi) 
 XRAY>   else 
 XRAY>     evaluate ($reject_obs=&obs_f) 
 EVALUATE: symbol $REJECT_OBS set to "fobs" (string)
 XRAY>     evaluate ($reject_sig=&obs_sigf) 
 EVALUATE: symbol $REJECT_SIG set to "sigma" (string)
 XRAY>   end if 
 XRAY> 
 XRAY>   declare name=ref_active domain=reciprocal type=integer end 
 XDECLARE: Object REF_ACTIVE has been declared.
 XRAY>   declare name=tst_active domain=reciprocal type=integer end 
 XDECLARE: Object TST_ACTIVE has been declared.
 XRAY> 
 XRAY>   do (ref_active=0) ( all ) 
 XSFAL: allocating space for integer reciprocal space object.
 Total of      6261 structure factor elements were selected.
 XRAY>   do (ref_active=1) ( ( $STRIP%reject_sig # 0 ) and 
 DO>                      ( &low_res >= d >= &high_res ) ) 
 Total of      6261 structure factor elements were selected.
 XRAY> 
 XRAY>   statistics overall 
 STATistics>     completeness 
 STATistics>     selection=( ref_active=1 ) 
 Total of      6261 structure factor elements were selected.
 STATistics>   end 
 XRAY>   evaluate ($total_compl=$expression1) 
 EVALUATE: symbol $TOTAL_COMPL set to   0.899052     (real)
 XRAY> 
 XRAY>   show sum(1) ( ref_active=1 ) 
 Sum of      6261 elements =              6261.0000
 XRAY>   evaluate ($total_read=$select) 
 EVALUATE: symbol $TOTAL_READ set to    6261.00     (real)
 XRAY>   evaluate ($total_theor=int(1./$total_compl * $total_read)) 
 EVALUATE: symbol $TOTAL_THEOR set to    6964.00     (real)
 XRAY> 
 XRAY>   show rms (amplitude($STRIP%reject_obs)) ( ref_active=1 ) 
 Rms of      6261 elements =               113.6123
 XRAY>   evaluate ($obs_high=$result*&obs_rms) 
 EVALUATE: symbol $OBS_HIGH set to   0.113612E+07 (real)
 XRAY>   show min (amplitude($STRIP%reject_obs)) ( ref_active=1 ) 
 Minimum of      6261 elements =                13.0500
 XRAY>   evaluate ($obs_low=$result) 
 EVALUATE: symbol $OBS_LOW set to    13.0500     (real)
 XRAY> 
 XRAY>   do (ref_active=0) ( all ) 
 Total of      6261 structure factor elements were selected.
 XRAY>   do (ref_active=1) 
 DO>                  ( ( amplitude($STRIP%reject_obs) > &sigma_cut*$STRIP%reject_sig ) and 
 DO>                    ( $STRIP%reject_sig # 0 ) and 
 DO>                    ( $obs_low <= amplitude($STRIP%reject_obs) <= $obs_high ) and 
 DO>                    ( &low_res >= d >= &high_res ) ) 
 Total of      6261 structure factor elements were selected.
 XRAY> 
 XRAY>   do (tst_active=0) (all) 
 XSFAL: allocating space for integer reciprocal space object.
 Total of      6261 structure factor elements were selected.
 XRAY>   if ( &BLANK%test_set = false ) then 
 NEXTCD: condition evaluated as true
 XRAY>     do (tst_active=1) (ref_active=1 and &STRIP%test_set=&test_flag) 
 Total of       476 structure factor elements were selected.
 XRAY>   end if 
 XRAY> 
 XRAY>   show sum(1) ( ref_active=1 and tst_active=0 ) 
 Sum of      5785 elements =              5785.0000
 XRAY>   evaluate ($total_work=$select) 
 EVALUATE: symbol $TOTAL_WORK set to    5785.00     (real)
 XRAY>   show sum(1) ( ref_active=1 and tst_active=1 ) 
 Sum of       476 elements =               476.0000
 XRAY>   evaluate ($total_test=$select) 
 EVALUATE: symbol $TOTAL_TEST set to    476.000     (real)
 XRAY>   evaluate ($total_used=$total_work+$total_test) 
 EVALUATE: symbol $TOTAL_USED set to    6261.00     (real)
 XRAY> 
 XRAY>   evaluate ($unobserved=$total_theor-$total_read) 
 EVALUATE: symbol $UNOBSERVED set to    703.000     (real)
 XRAY>   evaluate ($rejected=$total_read-$total_used) 
 EVALUATE: symbol $REJECTED set to    0.00000     (real)
 XRAY>   evaluate ($per_unobs=100*($unobserved/$total_theor)) 
 EVALUATE: symbol $PER_UNOBS set to    10.0948     (real)
 XRAY>   evaluate ($per_reject=100*($rejected/$total_theor)) 
 EVALUATE: symbol $PER_REJECT set to    0.00000     (real)
 XRAY>   evaluate ($per_used=100*($total_used/$total_theor)) 
 EVALUATE: symbol $PER_USED set to    89.9052     (real)
 XRAY>   evaluate ($per_work=100*($total_work/$total_theor)) 
 EVALUATE: symbol $PER_WORK set to    83.0701     (real)
 XRAY>   evaluate ($per_test=100*($total_test/$total_theor)) 
 EVALUATE: symbol $PER_TEST set to    6.83515     (real)
 XRAY> 
 XRAY>   associate fcalc ( &atom_select ) 
 SELRPN:   1240 atoms have been selected out of   1240
 XRAY> 
 XRAY>   tselection=( ref_active=1 ) 
 XRAY> 
 XRAY>   cvselection=( tst_active=1 ) 
 XRAY> 
 XRAY>   method=FFT 
 XRAY> 
 XRAY> {- MODIFIED 2/15/06 -} 
 XRAY> end 
 CNSsolve> 
 CNSsolve> 
 CNSsolve> show min ( b ) ( &atom_select ) 
 SELRPN:   1240 atoms have been selected out of   1240
 SHOW: minimum of selected elements =       3.530000
 CNSsolve> evaluate ($b_min=$result) 
 EVALUATE: symbol $B_MIN set to    3.53000     (real)
 CNSsolve> @@CNS_XTALMODULE:fft_parameter_check ( 
 ASSFIL: file fft_parameter_check opened.
 CNSsolve>! Module file: fft_parameter_check 
 CNSsolve>! 
 CNSsolve>! Function: determines the optimum setting for the B-factor inflation 
 CNSsolve>! given the high resolution limit, the gridding factor, and the minimum 
 CNSsolve>! B-factor of the model.   It also determines the recommended ELIM parameter 
 CNSsolve>! as a function of the high resolution limit. 
 CNSsolve>! 
 CNSsolve>! Reference: 
 CNSsolve>! 
 CNSsolve>! Gerard Bricogne (2001), 
 CNSsolve>!   International Tables for Crystallography, Volume B, 2001, p. 87 
 CNSsolve>! 
 CNSsolve>! CNS module 
 CNSsolve>! ********** 
 CNSsolve>! 
 CNSsolve>! Authors: Axel T. Brunger and Paul D. Adams 
 CNSsolve>! 
 CNSsolve>! copyright Yale University 
 CNSsolve>! 
 CNSsolve>! Requirements: 
 CNSsolve>! This module can only be used from the main level of CNS. 
 CNSsolve>! 
 CNSsolve>! 08/03/06 ATB 
 CNSsolve> 
 CNSsolve>module {fft_parameter_check} 
 MODULE-DECLARATION>( 
 MODULE-DECLARATION> &b_min=0;              {input: minimum B-factor of model} 
 MODULE-DECLARATION> &d_min=1.0;            {input: high resolution limit} 
 MODULE-DECLARATION> &q_factor=100;         {input: quality factor - 100 for 1% accuracy} 
 MODULE-DECLARATION> &grid=auto;            {input: if "auto" gridding factor is set automatically} 
 MODULE-DECLARATION>                        {       otherwise gridding factor set to <number>  } 
 MODULE-DECLARATION> &fft_memory=-1;        {input: fft memory; if "-1" use automatic mode } 
 MODULE-DECLARATION> 
 MODULE-DECLARATION> &fft_grid=$fft_grid;   {output: fft gridding factor} 
 MODULE-DECLARATION> &fft_b_add=$fft_b_add; {output: fft B addition} 
 MODULE-DECLARATION> &fft_elim=$fft_elim;   {output: fft elimit factor} 
 MODULE-DECLARATION> 
 MODULE-DECLARATION>) 
 MODULE-INVOCATION>                             d_min=&high_res; 
 &_2_D_MIN set to &_1_HIGH_RES 
 MODULE-INVOCATION>                             b_min=$b_min; 
 &_2_B_MIN set to $_1_B_MIN 
 MODULE-INVOCATION>                             grid=auto; 
 &_2_GRID set to auto 
 MODULE-INVOCATION>                             fft_memory=&fft_memory; 
 &_2_FFT_MEMORY set to &_1_FFT_MEMORY 
 MODULE-INVOCATION>                             fft_grid=$fft_grid; 
 &_2_FFT_GRID set to $_1_FFT_GRID 
 MODULE-INVOCATION>                             fft_b_add=$fft_b_add; 
 &_2_FFT_B_ADD set to $_1_FFT_B_ADD 
 MODULE-INVOCATION>                             fft_elim=$fft_elim; 
 &_2_FFT_ELIM set to $_1_FFT_ELIM 
 MODULE-INVOCATION>                                      ) 
 CNSsolve> 
 CNSsolve> set message ? end 
 MESSage=NORM
 CNSsolve> evaluate ($message_old=$result) 
 EVALUATE: symbol $MESSAGE_OLD set to "NORM" (string)
 CNSsolve> set echo ? end 
 ECHO=TRUE {ON}
 CNSsolve> evaluate ($echo_old=$result) 
 EVALUATE: symbol $ECHO_OLD set to TRUE (logical)
 CNSsolve> if ( $log_level = verbose ) then 
 NEXTCD: condition evaluated as false
 CNSsolve>   set echo=on message=normal end 
 CNSsolve> else 
 CNSsolve>   set echo=off message=off end 
 fft_parameter_check: using automatic memory option
 fft_parameter_check: minimum model B-factor = 3.53  A^2
 fft_parameter_check: high resolution limit = 2.18  A
 fft_parameter_check: fft gridding factor set to 0.3333
 fft_parameter_check: fft B factor offset set to 9.138  A^2
 fft_parameter_check: fft Elimit factor set to 8
 CNSsolve> 
 CNSsolve> 
 CNSsolve> xray 
 XRAY> {- END MODIFICATION -} 
 XRAY> 
 XRAY>   tolerance=0.0 lookup=false 
 XRAY> 
 XRAY>   if ( &wa >= 0 ) then 
 NEXTCD: condition evaluated as true
 XRAY>      wa=&wa 
 XRAY>   end if 
 XRAY> 
 XRAY> end 
 CNSsolve> 
 CNSsolve> if ( &BLANK%ncs_infile = false ) then 
 NEXTCD: condition evaluated as false
 CNSsolve>    inline @&ncs_infile 
 CNSsolve> end if 
 CNSsolve> 
 CNSsolve> if ( &BLANK%restraints_infile = false ) then 
 NEXTCD: condition evaluated as false
 CNSsolve>     @&restraints_infile 
 CNSsolve> end if 
 CNSsolve> 
 CNSsolve> do (store9=0) (all) 
 SELRPN:   1240 atoms have been selected out of   1240
 CNSsolve> 
 CNSsolve> evaluate ($nalt=1) 
 EVALUATE: symbol $NALT set to    1.00000     (real)
 CNSsolve> evaluate ($alt=1) 
 EVALUATE: symbol $ALT set to    1.00000     (real)
 CNSsolve> evaluate ($done=false) 
 EVALUATE: symbol $DONE set to FALSE (logical)
 CNSsolve> while ( $done = false ) loop nalt 
 NEXTCD: condition evaluated as true
 CNSsolve>   if ( &exist_conf_$alt = true ) then 
 NEXTCD: condition evaluated as true
 CNSsolve>     show sum(1) ( &conf_$alt ) 
 SELRPN:      0 atoms have been selected out of   1240
 SHOW: zero atoms selected
 CNSsolve>     if ( $result > 0 ) then 
 NEXTCD: condition evaluated as false
 CNSsolve>       evaluate ($nalt=$nalt+1) 
 CNSsolve>     end if 
 CNSsolve>   else 
 CNSsolve>     evaluate ($done=true) 
 CNSsolve>     evaluate ($nalt=$nalt-1) 
 CNSsolve>   end if 
 CNSsolve>   evaluate ($alt=$alt+1) 
 EVALUATE: symbol $ALT set to    2.00000     (real)
 CNSsolve> end loop nalt 
 CNSsolve> while ( $done = false ) loop nalt 
 NEXTCD: condition evaluated as true
 CNSsolve>   if ( &exist_conf_$alt = true ) then 
 NEXTCD: condition evaluated as true
 CNSsolve>     show sum(1) ( &conf_$alt ) 
 SELRPN:      0 atoms have been selected out of   1240
 SHOW: zero atoms selected
 CNSsolve>     if ( $result > 0 ) then 
 NEXTCD: condition evaluated as false
 CNSsolve>       evaluate ($nalt=$nalt+1) 
 CNSsolve>     end if 
 CNSsolve>   else 
 CNSsolve>     evaluate ($done=true) 
 CNSsolve>     evaluate ($nalt=$nalt-1) 
 CNSsolve>   end if 
 CNSsolve>   evaluate ($alt=$alt+1) 
 EVALUATE: symbol $ALT set to    3.00000     (real)
 CNSsolve> end loop nalt 
 CNSsolve> while ( $done = false ) loop nalt 
 NEXTCD: condition evaluated as true
 CNSsolve>   if ( &exist_conf_$alt = true ) then 
 NEXTCD: condition evaluated as true
 CNSsolve>     show sum(1) ( &conf_$alt ) 
 SELRPN:      0 atoms have been selected out of   1240
 SHOW: zero atoms selected
 CNSsolve>     if ( $result > 0 ) then 
 NEXTCD: condition evaluated as false
 CNSsolve>       evaluate ($nalt=$nalt+1) 
 CNSsolve>     end if 
 CNSsolve>   else 
 CNSsolve>     evaluate ($done=true) 
 CNSsolve>     evaluate ($nalt=$nalt-1) 
 CNSsolve>   end if 
 CNSsolve>   evaluate ($alt=$alt+1) 
 EVALUATE: symbol $ALT set to    4.00000     (real)
 CNSsolve> end loop nalt 
 CNSsolve> while ( $done = false ) loop nalt 
 NEXTCD: condition evaluated as true
 CNSsolve>   if ( &exist_conf_$alt = true ) then 
 NEXTCD: condition evaluated as true
 CNSsolve>     show sum(1) ( &conf_$alt ) 
 SELRPN:      0 atoms have been selected out of   1240
 SHOW: zero atoms selected
 CNSsolve>     if ( $result > 0 ) then 
 NEXTCD: condition evaluated as false
 CNSsolve>       evaluate ($nalt=$nalt+1) 
 CNSsolve>     end if 
 CNSsolve>   else 
 CNSsolve>     evaluate ($done=true) 
 CNSsolve>     evaluate ($nalt=$nalt-1) 
 CNSsolve>   end if 
 CNSsolve>   evaluate ($alt=$alt+1) 
 EVALUATE: symbol $ALT set to    5.00000     (real)
 CNSsolve> end loop nalt 
 CNSsolve> while ( $done = false ) loop nalt 
 NEXTCD: condition evaluated as true
 CNSsolve>   if ( &exist_conf_$alt = true ) then 
 NEXTCD: condition evaluated as false
 CNSsolve>     show sum(1) ( &conf_$alt ) 
 CNSsolve>     if ( $result > 0 ) then 
 CNSsolve>       evaluate ($nalt=$nalt+1) 
 CNSsolve>     end if 
 CNSsolve>   else 
 CNSsolve>     evaluate ($done=true) 
 EVALUATE: symbol $DONE set to TRUE (logical)
 CNSsolve>     evaluate ($nalt=$nalt-1) 
 EVALUATE: symbol $NALT set to    0.00000     (real)
 CNSsolve>   end if 
 CNSsolve>   evaluate ($alt=$alt+1) 
 EVALUATE: symbol $ALT set to    6.00000     (real)
 CNSsolve> end loop nalt 
 CNSsolve> while ( $done = false ) loop nalt 
 NEXTCD: condition evaluated as false
 CNSsolve>   if ( &exist_conf_$alt = true ) then 
 CNSsolve>     show sum(1) ( &conf_$alt ) 
 CNSsolve>     if ( $result > 0 ) then 
 CNSsolve>       evaluate ($nalt=$nalt+1) 
 CNSsolve>     end if 
 CNSsolve>   else 
 CNSsolve>     evaluate ($done=true) 
 CNSsolve>     evaluate ($nalt=$nalt-1) 
 CNSsolve>   end if 
 CNSsolve>   evaluate ($alt=$alt+1) 
 CNSsolve> end loop nalt 
 CNSsolve> 
 CNSsolve> evaluate ($alt=1) 
 EVALUATE: symbol $ALT set to    1.00000     (real)
 CNSsolve> while ( $alt <= $nalt ) loop alt 
 NEXTCD: condition evaluated as false
 CNSsolve>   do (store9=$alt) ( &conf_$alt ) 
 CNSsolve>   evaluate ($alt=$alt+1) 
 CNSsolve> end loop alt 
 CNSsolve> 
 CNSsolve> igroup 
 IGROup>   interaction ( &atom_select and not(attr store9 > 0)) 
 SELRPN:   1240 atoms have been selected out of   1240
 SELRPN>               ( &atom_select and not(attr store9 > 0)) 
 SELRPN:   1240 atoms have been selected out of   1240
 IGROup>   evaluate ($alt=1) 
 EVALUATE: symbol $ALT set to    1.00000     (real)
 IGROup>   while ( $alt <= $nalt ) loop alcs 
 NEXTCD: condition evaluated as false
 IGROup>     interaction ( &atom_select and ( attr store9 = $alt or attr store9 = 0 )) 
 IGROup>                 ( &atom_select and ( attr store9 = $alt )) 
 IGROup>     evaluate ($alt=$alt+1) 
 IGROup>   end loop alcs 
 IGROup> end 
 CNSsolve> 
 CNSsolve> {- check isolated atoms and atoms at special positions and add to 
 CNSsolve>    list of fixed atoms if needed - store9 will be used -} 
 CNSsolve> 
 CNSsolve> @CNS_XTALMODULE:setupfixed ( 
 ASSFIL: file setupfixed opened.
 CNSsolve>! Module file: setupfixed 
 CNSsolve>! 
 CNSsolve>! CNS module 
 CNSsolve>! ********** 
 CNSsolve>! 
 CNSsolve>! Authors: Axel Brunger 
 CNSsolve>! 
 CNSsolve>! copyright Yale University 
 CNSsolve>! 
 CNSsolve>! Function: 
 CNSsolve>! 
 CNSsolve>!    Sets up fixed atom selection and 
 CNSsolve>!    performs various checks for 
 CNSsolve>!    1. isolated atoms 
 CNSsolve>!    2. isolated di-atomic molecules 
 CNSsolve>!    3. atoms at special positions 
 CNSsolve>! 
 CNSsolve>!    Adds isolated atoms, diatomic molecules, and/or special-position atoms to the 
 CNSsolve>!    fixed atom selection. 
 CNSsolve>! 
 CNSsolve>! Requirements: 
 CNSsolve>!    Needs to be called from cns main level 
 CNSsolve> 
 CNSsolve>module {setupfixed} 
 MODULE-DECLARATION> 
 MODULE-DECLARATION>( 
 MODULE-DECLARATION>  &mode;              {string}                 {"minimization", "cartesian", "torsion"} 
 MODULE-DECLARATION>  &atom_select;       {selection }             {input: all selected atoms for refinement} 
 MODULE-DECLARATION>  &atom_fixed;        {selection }             {input: explicitly fixed atoms} 
 MODULE-DECLARATION>  &atom_total_fixed;  {atomic property array } {output: all fixed atoms} 
 MODULE-DECLARATION>  &atom_multiplicity; {atomic property array } {output: multiplicity of atoms} 
 MODULE-DECLARATION>  &mset=$mset;        {symbol}                 {output: number of disconnected sets} 
 MODULE-DECLARATION> 
 MODULE-DECLARATION>) 
 MODULE-INVOCATION>                           mode="minimization"; 
 &_2_MODE set to "minimization" 
 MODULE-INVOCATION>                           atom_select=&atom_select; 
 &_2_ATOM_SELECT set to &_1_ATOM_SELECT 
 MODULE-INVOCATION>                           atom_fixed=&atom_fixed; 
 &_2_ATOM_FIXED set to &_1_ATOM_FIXED 
 MODULE-INVOCATION>                           atom_total_fixed=store9; 
 &_2_ATOM_TOTAL_FIXED set to store9 
 MODULE-INVOCATION>                           atom_multiplicity=rmsd; 
 &_2_ATOM_MULTIPLICITY set to rmsd 
 MODULE-INVOCATION>                           ) 
 CNSsolve> 
 CNSsolve>! 
 CNSsolve>!MODIFICATION: set message level to on for show statements, ATB 10/18/10 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve> set message ? end 
 MESSage=NORM
 CNSsolve> evaluate ($message_old_fix=$result) 
 EVALUATE: symbol $MESSAGE_OLD_FIX set to "NORM" (string)
 CNSsolve> set echo ? end 
 ECHO=TRUE {ON}
 CNSsolve> evaluate ($echo_old_fix=$result) 
 EVALUATE: symbol $ECHO_OLD_FIX set to TRUE (logical)
 CNSsolve> if ( $log_level = verbose ) then 
 NEXTCD: condition evaluated as false
 CNSsolve>   set echo=on message=normal end 
 CNSsolve> else 
 CNSsolve>   set echo=off message=off end 
 CONNECt: selected atoms form    155 covalently disconnected set(s)

 list of isolated (non-covalently bonded) atoms:
 SELRPN:    153 atoms have been selected out of   1240
 ( A    HOH  301  O    )  O   
 ( A    HOH  302  O    )  O   
 ( A    HOH  303  O    )  O   
 ( A    HOH  304  O    )  O   
 ( A    HOH  305  O    )  O   
 ( A    HOH  306  O    )  O   
 ( A    HOH  307  O    )  O   
 ( A    HOH  308  O    )  O   
 ( A    HOH  309  O    )  O   
 ( A    HOH  310  O    )  O   
 ( A    HOH  311  O    )  O   
 ( A    HOH  312  O    )  O   
 ( A    HOH  313  O    )  O   
 ( A    HOH  314  O    )  O   
 ( A    HOH  315  O    )  O   
 ( A    HOH  316  O    )  O   
 ( A    HOH  317  O    )  O   
 ( A    HOH  318  O    )  O   
 ( A    HOH  319  O    )  O   
 ( A    HOH  320  O    )  O   
 ( A    HOH  321  O    )  O   
 ( A    HOH  322  O    )  O   
 ( A    HOH  323  O    )  O   
 ( A    HOH  324  O    )  O   
 ( A    HOH  325  O    )  O   
 ( A    HOH  326  O    )  O   
 ( A    HOH  327  O    )  O   
 ( A    HOH  328  O    )  O   
 ( A    HOH  329  O    )  O   
 ( A    HOH  330  O    )  O   
 ( A    HOH  331  O    )  O   
 ( A    HOH  332  O    )  O   
 ( A    HOH  333  O    )  O   
 ( A    HOH  334  O    )  O   
 ( A    HOH  335  O    )  O   
 ( A    HOH  336  O    )  O   
 ( A    HOH  337  O    )  O   
 ( A    HOH  338  O    )  O   
 ( A    HOH  339  O    )  O   
 ( A    HOH  340  O    )  O   
 ( A    HOH  341  O    )  O   
 ( A    HOH  342  O    )  O   
 ( A    HOH  343  O    )  O   
 ( A    HOH  344  O    )  O   
 ( A    HOH  345  O    )  O   
 ( A    HOH  346  O    )  O   
 ( A    HOH  347  O    )  O   
 ( A    HOH  348  O    )  O   
 ( A    HOH  349  O    )  O   
 ( A    HOH  350  O    )  O   
 ( A    HOH  351  O    )  O   
 ( A    HOH  352  O    )  O   
 ( A    HOH  353  O    )  O   
 ( A    HOH  354  O    )  O   
 ( A    HOH  355  O    )  O   
 ( A    HOH  356  O    )  O   
 ( A    HOH  357  O    )  O   
 ( A    HOH  358  O    )  O   
 ( A    HOH  359  O    )  O   
 ( A    HOH  360  O    )  O   
 ( A    HOH  361  O    )  O   
 ( A    HOH  362  O    )  O   
 ( A    HOH  363  O    )  O   
 ( A    HOH  364  O    )  O   
 ( A    HOH  365  O    )  O   
 ( A    HOH  366  O    )  O   
 ( A    HOH  367  O    )  O   
 ( A    HOH  368  O    )  O   
 ( A    HOH  369  O    )  O   
 ( A    HOH  370  O    )  O   
 ( A    HOH  371  O    )  O   
 ( A    HOH  372  O    )  O   
 ( A    HOH  373  O    )  O   
 ( A    HOH  374  O    )  O   
 ( A    HOH  375  O    )  O   
 ( A    HOH  376  O    )  O   
 ( A    HOH  377  O    )  O   
 ( A    HOH  378  O    )  O   
 ( A    HOH  379  O    )  O   
 ( A    HOH  380  O    )  O   
 ( A    HOH  381  O    )  O   
 ( A    HOH  382  O    )  O   
 ( A    HOH  383  O    )  O   
 ( A    HOH  384  O    )  O   
 ( A    HOH  385  O    )  O   
 ( A    HOH  386  O    )  O   
 ( A    HOH  387  O    )  O   
 ( A    HOH  388  O    )  O   
 ( A    HOH  389  O    )  O   
 ( A    HOH  390  O    )  O   
 ( A    HOH  391  O    )  O   
 ( A    HOH  392  O    )  O   
 ( A    HOH  393  O    )  O   
 ( A    HOH  394  O    )  O   
 ( A    HOH  395  O    )  O   
 ( A    HOH  396  O    )  O   
 ( A    HOH  397  O    )  O   
 ( A    HOH  398  O    )  O   
 ( A    HOH  399  O    )  O   
 ( A    HOH  400  O    )  O   
 ( A    HOH  401  O    )  O   
 ( A    HOH  402  O    )  O   
 ( A    HOH  403  O    )  O   
 ( A    HOH  404  O    )  O   
 ( A    HOH  405  O    )  O   
 ( A    HOH  406  O    )  O   
 ( A    HOH  407  O    )  O   
 ( A    HOH  408  O    )  O   
 ( A    HOH  409  O    )  O   
 ( A    HOH  410  O    )  O   
 ( A    HOH  411  O    )  O   
 ( A    HOH  412  O    )  O   
 ( A    HOH  413  O    )  O   
 ( A    HOH  414  O    )  O   
 ( A    HOH  415  O    )  O   
 ( A    HOH  416  O    )  O   
 ( A    HOH  417  O    )  O   
 ( A    HOH  418  O    )  O   
 ( A    HOH  419  O    )  O   
 ( A    HOH  420  O    )  O   
 ( A    HOH  421  O    )  O   
 ( A    HOH  422  O    )  O   
 ( A    HOH  423  O    )  O   
 ( A    HOH  424  O    )  O   
 ( A    HOH  425  O    )  O   
 ( A    HOH  426  O    )  O   
 ( A    HOH  427  O    )  O   
 ( A    HOH  428  O    )  O   
 ( A    HOH  429  O    )  O   
 ( A    HOH  430  O    )  O   
 ( A    HOH  431  O    )  O   
 ( A    HOH  432  O    )  O   
 ( A    HOH  433  O    )  O   
 ( A    HOH  434  O    )  O   
 ( A    HOH  435  O    )  O   
 ( A    HOH  436  O    )  O   
 ( A    HOH  437  O    )  O   
 ( A    HOH  438  O    )  O   
 ( A    HOH  439  O    )  O   
 ( A    HOH  440  O    )  O   
 ( A    HOH  441  O    )  O   
 ( A    HOH  442  O    )  O   
 ( A    HOH  443  O    )  O   
 ( A    HOH  444  O    )  O   
 ( A    HOH  445  O    )  O   
 ( A    HOH  446  O    )  O   
 ( A    HOH  447  O    )  O   
 ( A    HOH  448  O    )  O   
 ( A    HOH  449  O    )  O   
 ( A    HOH  450  O    )  O   
 ( A    HOH  451  O    )  O   
 ( A    HOH  452  O    )  O   
 ( A    HOH  453  O    )  O   

 list of isolated (non-covalently bonded) di-atomic molecules:
 SELRPN:      0 atoms have been selected out of   1240
 SHOW: zero atoms selected
 --none--

 list of atoms at special positions:
 SELRPN:      0 atoms have been selected out of   1240
 SHOW: zero atoms selected
 --none--


 SELRPN:      0 atoms have been selected out of   1240
 SHOW: zero atoms selected

 0 atoms at special positions,
 explicitly fixed atoms, and atoms not selected for
 refinement will be fixed.

 CNSsolve> 
 CNSsolve> fix selection=( store9 ) end 
 SELRPN:      0 atoms have been selected out of   1240
 CNSsolve> 
 CNSsolve> fastnb grid end 
 CNSsolve> 
 CNSsolve> flags 
 FLAGS>    exclude * include xref 
 FLAGS>   ? 
 EFLAGS: the following energy flags are set
 EFLAGS: XREF
 FLAGS> end 
 CNSsolve> 
 CNSsolve> if ( &BLANK%force_field_infile = true ) then 
 NEXTCD: condition evaluated as true
 CNSsolve>    flags 
 FLAGS>       exclude elec pele vdw pvdw 
 FLAGS>      ? 
 EFLAGS: the following energy flags are set
 EFLAGS: XREF
 FLAGS>    end 
 CNSsolve> else 
 CNSsolve>     @&force_field_infile 
 CNSsolve> end if 
 CNSsolve> 
 CNSsolve> show sum(1) (&atom_harm) 
 SELRPN:      0 atoms have been selected out of   1240
 SHOW: zero atoms selected
 CNSsolve> if ( $result > 0 ) then 
 NEXTCD: condition evaluated as false
 CNSsolve>   evaluate ($harmonic=true) 
 CNSsolve> else 
 CNSsolve>   evaluate ($harmonic=false) 
 EVALUATE: symbol $HARMONIC set to FALSE (logical)
 CNSsolve> end if 
 CNSsolve> 
 CNSsolve> xray 
 XRAY>   predict 
 PREDict>     mode=reciprocal 
 PREDict>     to=fcalc 
 PREDict>     selection=(ref_active=1) 
 Total of      6261 structure factor elements were selected.
 PREDict>     atomselection=( &atom_select ) 
 SELRPN:   1240 atoms have been selected out of   1240
 PREDict>   end 
 FCALC: #scatt.=   1240 #anomalous=   0 #special pos.=  0 occupancies=1
 XSFAL: allocating space for complex reciprocal space object.
 %XFFT-AUTOmem: increasing memory allocation to    2000000
 XFFT: using grid [  48,  72, 108] and sublattice [  48(  49),  72(  73), 108]
 XRAY> end 
 CNSsolve> 
 CNSsolve> {- BEGIN MODIFICATION -} 
 CNSsolve> @CNS_XTALMODULE:scale_and_solvent_grid_search ( 
 ASSFIL: file scale_and_solvent_grid_search opened.
 CNSsolve>! Module file: scale_and_solvent_grid_search 
 CNSsolve>! 
 CNSsolve>! Function: determines best bulk solvent model by a grid search in ( k_sol ) space. 
 CNSsolve>!           For each pair of values, the optimum B_sol is determined by least-squares minimization. 
 CNSsolve>!           The module also computes an overall (an)-isotropic B-tensor and applies the isotropic component to the 
 CNSsolve>!           model structure factors, and bulk solvent structure factors; the negated modified 
 CNSsolve>!           B-tensor (-Ucif, with the isotropic component removed) is then applied to the 
 CNSsolve>!           observed amplitudes, sigmas, intensities, and their sigmas.  The corresponding Ucart is 
 CNSsolve>!           passed back to the calling script file. 
 CNSsolve>! 
 CNSsolve>! 
 CNSsolve>! CNS module 
 CNSsolve>! ********** 
 CNSsolve>! 
 CNSsolve>! Authors: Axel T. Brunger and Paul D. Adams 
 CNSsolve>! 
 CNSsolve>! copyright Yale University 
 CNSsolve>! 
 CNSsolve>! Requirements: 
 CNSsolve>! This module can only be used from the main level of CNS. 
 CNSsolve>! 
 CNSsolve>! 6/28/2006 
 CNSsolve> 
 CNSsolve>module {scale_and_solvent_grid_search} 
 MODULE-DECLARATION>( 
 MODULE-DECLARATION> &bscale="no";         {input: "no" | "isotropic" | "anisotropic" } 
 MODULE-DECLARATION> 
 MODULE-DECLARATION> &sel=all;             {input: all active structure factors} 
 MODULE-DECLARATION> &sel_test=none;       {input: test set reflections} 
 MODULE-DECLARATION> &atom_select=( all ); {input: atom selection for all atoms that contribute to calculated structure factor} 
 MODULE-DECLARATION> 
 MODULE-DECLARATION> &bulk_sol=false;      {input: logical flag (true/false) specifying if bulk solvent correction should be computed} 
 MODULE-DECLARATION> &bulk_mask="";        {optional input: mask file for bulk solvent model - it not specified mask will be generated from selected atoms} 
 MODULE-DECLARATION> &bulk_atoms=( all );  {input: atoms used to create solvent mask} 
 MODULE-DECLARATION> 
 MODULE-DECLARATION> &sol_auto=true;       {input: logical flag (true/false) specifying if grid search shall be performed } 
 MODULE-DECLARATION> &sol_k=0.3;           {for sol_auto=false: solvent density fixed at specified value} 
 MODULE-DECLARATION> &sol_b=50.;           {for sol_auto=false: solvent B factor fixed at specified value} 
 MODULE-DECLARATION> &sol_rad=1.0;         {solvent radius (fixed at specified value)} 
 MODULE-DECLARATION> &sol_shrink=1.0;      {shrink factor (fixed at specified value)} 
 MODULE-DECLARATION> 
 MODULE-DECLARATION> &sol_k_range=0.1 0.2 0.25 0.28 0.30 0.32 0.33 0.34 0.35 0.36 0.37 0.38 0.4 0.42 0.45 0.5 0.6; {for sol_auto=true: parameters for sol_k grid search} 
 MODULE-DECLARATION> 
 MODULE-DECLARATION> &fcalc="";            {input/output: calculated structure factors - modified at output (isotropic portion of B-tensor applied)} 
 MODULE-DECLARATION> 
 MODULE-DECLARATION> &obs_f="";            {input/output: observed structure factors - modified at output (negative of anisotropic B-tensor (w/o isotropic portion) applied)} 
 MODULE-DECLARATION> 
 MODULE-DECLARATION> &obs_sigf="";         {input/putput: corresponding sigma array - modified at output (negative of anisotropic B-tensor (w/o isotropic portion) applied)} 
 MODULE-DECLARATION> 
 MODULE-DECLARATION> &obs_i="";            {input/output: observed intensity data - modified at output (negative of anisotropic B-tensor (w/o isotropic portion) applied)} 
 MODULE-DECLARATION> 
 MODULE-DECLARATION> &obs_sigi="";         {input/output: corresponding sigma array - modified at output (negative of anisotropic B-tensor (w/o isotropic portion) applied)} 
 MODULE-DECLARATION> 
 MODULE-DECLARATION> &fpart="";            {output: bulk solvent structure factors (isotropic portion of B-tensor applied)} 
 MODULE-DECLARATION> 
 MODULE-DECLARATION> &Baniso_11;           {required output: anisotropic B-tensor (Ucart) of atomic model, with isotropic component removed } 
 MODULE-DECLARATION> &Baniso_22; 
 MODULE-DECLARATION> &Baniso_33; 
 MODULE-DECLARATION> &Baniso_12; 
 MODULE-DECLARATION> &Baniso_13; 
 MODULE-DECLARATION> &Baniso_23; 
 MODULE-DECLARATION> &Biso;                {required output: isotropic component of the B-tensor } 
 MODULE-DECLARATION> 
 MODULE-DECLARATION> &sol_k_best;          {required output: k_sol of best solvent model} 
 MODULE-DECLARATION> &sol_b_best;          {required output: b_sol of best solvent model} 
 MODULE-DECLARATION> &solrad_best;         {required output: solrad of solvent model that was actually used (for compatibility with previous versions of this module)} 
 MODULE-DECLARATION> &shrink_best;         {required output: shrink value of solvent model that was actually used (for compatibility with previous versions of this module)} 
 MODULE-DECLARATION> 
 MODULE-DECLARATION> &b=b;                 {input/output: atomic B-factor array - isotropic portion of B-factor tensor added } 
 MODULE-DECLARATION> 
 MODULE-DECLARATION> &low_b_flag;          {required output: if true then there were some negative B-factors that have been set to zero } 
 MODULE-DECLARATION> 
 MODULE-DECLARATION> &sol_output="";       {optional output: listing filename for grid search} 
 MODULE-DECLARATION> 
 MODULE-DECLARATION>) 
 MODULE-INVOCATION>                             bscale=&bscale; 
 &_2_BSCALE set to &_1_BSCALE 
 MODULE-INVOCATION>                             sel=( ref_active=1 ); 
 &_2_SEL set to ( ref_active = 1 ) 
 MODULE-INVOCATION>                             sel_test=( tst_active=1 ); 
 &_2_SEL_TEST set to ( tst_active = 1 ) 
 MODULE-INVOCATION>                             atom_select=( &atom_select ); 
 &_2_ATOM_SELECT set to ( &_1_ATOM_SELECT ) 
 MODULE-INVOCATION>                             bulk_sol=&bulk_sol; 
 &_2_BULK_SOL set to &_1_BULK_SOL 
 MODULE-INVOCATION>                             bulk_mask=&bulk_mask_infile; 
 &_2_BULK_MASK set to &_1_BULK_MASK_INFILE 
 MODULE-INVOCATION>                             bulk_atoms=( &atom_select ); 
 &_2_BULK_ATOMS set to ( &_1_ATOM_SELECT ) 
 MODULE-INVOCATION> 
 MODULE-INVOCATION>                             sol_auto=&sol_auto; 
 &_2_SOL_AUTO set to &_1_SOL_AUTO 
 MODULE-INVOCATION>                             sol_k=&sol_k; 
 &_2_SOL_K set to &_1_SOL_K 
 MODULE-INVOCATION>                             sol_b=&sol_b; 
 &_2_SOL_B set to &_1_SOL_B 
 MODULE-INVOCATION>                             sol_rad=&sol_rad; 
 &_2_SOL_RAD set to &_1_SOL_RAD 
 MODULE-INVOCATION>                             sol_shrink=&sol_shrink; 
 &_2_SOL_SHRINK set to &_1_SOL_SHRINK 
 MODULE-INVOCATION> 
 MODULE-INVOCATION>                             fcalc=fcalc; 
 &_2_FCALC set to fcalc 
 MODULE-INVOCATION>                             obs_f=&STRIP%obs_f; 
 &_2_OBS_F set to &STRIP%_1_OBS_F 
 MODULE-INVOCATION>                             obs_sigf=&STRIP%obs_sigf; 
 &_2_OBS_SIGF set to &STRIP%_1_OBS_SIGF 
 MODULE-INVOCATION>                             obs_i=$STRIP%obs_i; 
 &_2_OBS_I set to $STRIP%_1_OBS_I 
 MODULE-INVOCATION>                             obs_sigi=$STRIP%obs_sigi; 
 &_2_OBS_SIGI set to $STRIP%_1_OBS_SIGI 
 MODULE-INVOCATION>                             fpart=fbulk; 
 &_2_FPART set to fbulk 
 MODULE-INVOCATION> 
 MODULE-INVOCATION>! 
 MODULE-INVOCATION>! Begin modification (6/28/06) 
 MODULE-INVOCATION>                             Baniso_11=$Baniso_11; 
 &_2_BANISO_11 set to $_1_BANISO_11 
 MODULE-INVOCATION>                             Baniso_22=$Baniso_22; 
 &_2_BANISO_22 set to $_1_BANISO_22 
 MODULE-INVOCATION>                             Baniso_33=$Baniso_33; 
 &_2_BANISO_33 set to $_1_BANISO_33 
 MODULE-INVOCATION>                             Baniso_12=$Baniso_12; 
 &_2_BANISO_12 set to $_1_BANISO_12 
 MODULE-INVOCATION>                             Baniso_13=$Baniso_13; 
 &_2_BANISO_13 set to $_1_BANISO_13 
 MODULE-INVOCATION>                             Baniso_23=$Baniso_23; 
 &_2_BANISO_23 set to $_1_BANISO_23 
 MODULE-INVOCATION>                             Biso=$Biso_model; 
 &_2_BISO set to $_1_BISO_MODEL 
 MODULE-INVOCATION>! End modification 
 MODULE-INVOCATION>! 
 MODULE-INVOCATION> 
 MODULE-INVOCATION>                             sol_k_best=$sol_k_ref; 
 &_2_SOL_K_BEST set to $_1_SOL_K_REF 
 MODULE-INVOCATION>                             sol_b_best=$sol_b_ref; 
 &_2_SOL_B_BEST set to $_1_SOL_B_REF 
 MODULE-INVOCATION>			     solrad_best=$solrad_best; 
 &_2_SOLRAD_BEST set to $_1_SOLRAD_BEST 
 MODULE-INVOCATION>			     shrink_best=$shrink_best; 
 &_2_SHRINK_BEST set to $_1_SHRINK_BEST 
 MODULE-INVOCATION> 
 MODULE-INVOCATION>                             b=b; 
 &_2_B set to b 
 MODULE-INVOCATION> 
 MODULE-INVOCATION>                             low_b_flag=$low_b_flag; 
 &_2_LOW_B_FLAG set to $_1_LOW_B_FLAG 
 MODULE-INVOCATION> 
 MODULE-INVOCATION>                             sol_output=&sol_output; 
 &_2_SOL_OUTPUT set to &_1_SOL_OUTPUT 
 MODULE-INVOCATION> 
 MODULE-INVOCATION>                             ) 
 CNSsolve> 
 CNSsolve> set message ? end 
 MESSage=NORM
 CNSsolve> evaluate ($message_old2=$result) 
 EVALUATE: symbol $MESSAGE_OLD2 set to "NORM" (string)
 CNSsolve> set echo ? end 
 ECHO=TRUE {ON}
 CNSsolve> evaluate ($echo_old2=$result) 
 EVALUATE: symbol $ECHO_OLD2 set to TRUE (logical)
 CNSsolve> if ( $log_level = verbose ) then 
 NEXTCD: condition evaluated as false
 CNSsolve>   set echo=on message=normal end 
 CNSsolve> else 
 CNSsolve>   set echo=off message=off end 

 trying solvent model with fixed k_sol = 0.1 , solrad = 1.0, shrink = 1.0, bscale option = "isotropic"
 grid parameter for solvent mask calculation : 0.3333
 XMASK:     1240 atoms have been selected for mask calculation.
 Minimum brick that covers asymmetric unit:
   A=     0,...,    24  B=     0,...,    36  C=     0,...,   108
 XMASK: average mask radius around selected atoms  1.6669 A
 XMASK: probe radius=  1.0000 shrink radius=  1.0000
 XMASK: volume inside mask=   70.2803% (MASK<=0)
 XMASK: volume outside mask=   29.7197% (MASK=1)
 %XSCALE: aborting termination - errors.
 %%%XSCALE-err: diverging from solution.
 XSCALE: K<i> has been multiplied by the overall scale ($XSCFFK)   0.735
 refined solvent parameters: sol_k = 0.1  sol_b = -52.8962
>>>> Overall R-value for test set: 0.344582
>>>> Overall R-value for working set: 0.283047

 trying solvent model with fixed k_sol = 0.2 , solrad = 1.0, shrink = 1.0, bscale option = "isotropic"
 %XSCALE: aborting termination - errors.
 %%%XSCALE-err: diverging from solution.
 XSCALE: K<i> has been multiplied by the overall scale ($XSCFFK)   0.807
 refined solvent parameters: sol_k = 0.2  sol_b = -7.65742
>>>> Overall R-value for test set: 0.292998
>>>> Overall R-value for working set: 0.248899

 trying solvent model with fixed k_sol = 0.25 , solrad = 1.0, shrink = 1.0, bscale option = "isotropic"
 %XSCALE: aborting termination - errors.
 %%%XSCALE-err: diverging from solution.
 XSCALE: K<i> has been multiplied by the overall scale ($XSCFFK)   0.905
 refined solvent parameters: sol_k = 0.25  sol_b = 5.62353
>>>> Overall R-value for test set: 0.280702
>>>> Overall R-value for working set: 0.240805

 trying solvent model with fixed k_sol = 0.28 , solrad = 1.0, shrink = 1.0, bscale option = "isotropic"
 %XSCALE: aborting termination - errors.
 %%%XSCALE-err: diverging from solution.
 XSCALE: K<i> has been multiplied by the overall scale ($XSCFFK)   0.900
 refined solvent parameters: sol_k = 0.28  sol_b = 10.9403
>>>> Overall R-value for test set: 0.27446
>>>> Overall R-value for working set: 0.237611

 trying solvent model with fixed k_sol = 0.3 , solrad = 1.0, shrink = 1.0, bscale option = "isotropic"
 %XSCALE: aborting termination - errors.
 %%%XSCALE-err: diverging from solution.
 XSCALE: K<i> has been multiplied by the overall scale ($XSCFFK)   0.900
 refined solvent parameters: sol_k = 0.3  sol_b = 15.7084
>>>> Overall R-value for test set: 0.270753
>>>> Overall R-value for working set: 0.235765

 trying solvent model with fixed k_sol = 0.32 , solrad = 1.0, shrink = 1.0, bscale option = "isotropic"
 refined solvent parameters: sol_k = 0.32  sol_b = 19.5339
>>>> Overall R-value for test set: 0.267213
>>>> Overall R-value for working set: 0.234237

 trying solvent model with fixed k_sol = 0.33 , solrad = 1.0, shrink = 1.0, bscale option = "isotropic"
 %XSCALE: aborting termination - errors.
 %%%XSCALE-err: diverging from solution.
 XSCALE: K<i> has been multiplied by the overall scale ($XSCFFK)   0.890
 refined solvent parameters: sol_k = 0.33  sol_b = 21.3109
>>>> Overall R-value for test set: 0.26533
>>>> Overall R-value for working set: 0.233717

 trying solvent model with fixed k_sol = 0.34 , solrad = 1.0, shrink = 1.0, bscale option = "isotropic"
 %XSCALE: aborting termination - errors.
 %%%XSCALE-err: diverging from solution.
 XSCALE: K<i> has been multiplied by the overall scale ($XSCFFK)   0.883
 refined solvent parameters: sol_k = 0.34  sol_b = 23.2077
>>>> Overall R-value for test set: 0.263736
>>>> Overall R-value for working set: 0.233347

 trying solvent model with fixed k_sol = 0.35 , solrad = 1.0, shrink = 1.0, bscale option = "isotropic"
 %XSCALE: aborting termination - errors.
 %%%XSCALE-err: diverging from solution.
 XSCALE: K<i> has been multiplied by the overall scale ($XSCFFK)   0.890
 refined solvent parameters: sol_k = 0.35  sol_b = 25.6611
>>>> Overall R-value for test set: 0.26227
>>>> Overall R-value for working set: 0.233254

 trying solvent model with fixed k_sol = 0.36 , solrad = 1.0, shrink = 1.0, bscale option = "isotropic"
 %XSCALE: aborting termination - errors.
 %%%XSCALE-err: diverging from solution.
 XSCALE: K<i> has been multiplied by the overall scale ($XSCFFK)   0.884
 refined solvent parameters: sol_k = 0.36  sol_b = 28.0814
>>>> Overall R-value for test set: 0.261077
>>>> Overall R-value for working set: 0.233256

 trying solvent model with fixed k_sol = 0.37 , solrad = 1.0, shrink = 1.0, bscale option = "isotropic"
 %XSCALE: aborting termination - errors.
 %%%XSCALE-err: diverging from solution.
 XSCALE: K<i> has been multiplied by the overall scale ($XSCFFK)   0.888
 refined solvent parameters: sol_k = 0.37  sol_b = 31.0516
>>>> Overall R-value for test set: 0.260108
>>>> Overall R-value for working set: 0.233327

 trying solvent model with fixed k_sol = 0.38 , solrad = 1.0, shrink = 1.0, bscale option = "isotropic"
 %XSCALE: aborting termination - errors.
 %%%XSCALE-err: diverging from solution.
 XSCALE: K<i> has been multiplied by the overall scale ($XSCFFK)   0.888
 refined solvent parameters: sol_k = 0.38  sol_b = 33.3237
>>>> Overall R-value for test set: 0.259831
>>>> Overall R-value for working set: 0.233381

 trying solvent model with fixed k_sol = 0.4 , solrad = 1.0, shrink = 1.0, bscale option = "isotropic"
 %XSCALE: aborting termination - errors.
 %%%XSCALE-err: diverging from solution.
 XSCALE: K<i> has been multiplied by the overall scale ($XSCFFK)   0.893
 refined solvent parameters: sol_k = 0.4  sol_b = 35.6392
>>>> Overall R-value for test set: 0.26255
>>>> Overall R-value for working set: 0.23346

 trying solvent model with fixed k_sol = 0.42 , solrad = 1.0, shrink = 1.0, bscale option = "isotropic"
 %XSCALE: aborting termination - errors.
 %%%XSCALE-err: diverging from solution.
 XSCALE: K<i> has been multiplied by the overall scale ($XSCFFK)   0.890
 refined solvent parameters: sol_k = 0.42  sol_b = 40.7959
>>>> Overall R-value for test set: 0.262586
>>>> Overall R-value for working set: 0.233399

 trying solvent model with fixed k_sol = 0.45 , solrad = 1.0, shrink = 1.0, bscale option = "isotropic"
 %XSCALE: aborting termination - errors.
 %%%XSCALE-err: diverging from solution.
 XSCALE: K<i> has been multiplied by the overall scale ($XSCFFK)   0.886
 refined solvent parameters: sol_k = 0.45  sol_b = 48.6389
>>>> Overall R-value for test set: 0.265306
>>>> Overall R-value for working set: 0.233441

 trying solvent model with fixed k_sol = 0.5 , solrad = 1.0, shrink = 1.0, bscale option = "isotropic"
 %XSCALE: aborting termination - errors.
 %%%XSCALE-err: diverging from solution.
 XSCALE: K<i> has been multiplied by the overall scale ($XSCFFK)   0.898
 refined solvent parameters: sol_k = 0.5  sol_b = 69.1994
>>>> Overall R-value for test set: 0.270458
>>>> Overall R-value for working set: 0.234937

 trying solvent model with fixed k_sol = 0.6 , solrad = 1.0, shrink = 1.0, bscale option = "isotropic"
 %XSCALE: aborting termination - errors.
 %%%XSCALE-err: diverging from solution.
 XSCALE: K<i> has been multiplied by the overall scale ($XSCFFK)   0.951
 refined solvent parameters: sol_k = 0.6  sol_b = 106.255
>>>> Overall R-value for test set: 0.283971
>>>> Overall R-value for working set: 0.240142

 now recomputing solvent model for best parameters
 best sol_k = 0.35
 best sol_b = 25.6611
 Note: isotropic scaling is now applied to Fcalc = -1.47874

 %XSCALE: aborting termination - errors.
 %%%XSCALE-err: diverging from solution.
 XSCALE: K<i> has been multiplied by the overall scale ($XSCFFK)   0.862
 using fixed solvent parameters: sol_k = 0.35  sol_b = 25.5332

 Solvent model and B-scaling completed
 Solvent model sol_k = 0.35
 Solvent model sol_b = 25.5332
 Solvent model solrad = 1
 Solvent model shrink = 1
 The isotropic component of B scaling ( -1.60664 ) has been added to the B-factors of the atomic model

 CNSsolve> 
 CNSsolve> 
 CNSsolve> 
 CNSsolve> xray 
 XRAY>   @@CNS_XTALMODULE:calculate_r ( 
 ASSFIL: file calculate_r opened.
 XRAY>! Module file: calculate_r 
 XRAY>! 
 XRAY>! CNS module 
 XRAY>! ************ 
 XRAY>! 
 XRAY>! Authors: Axel Brunger and Paul Adams 
 XRAY>! 
 XRAY>! copyright Yale University 
 XRAY>! 
 XRAY>! Function: 
 XRAY>!    Calculates crystallographic R-values 
 XRAY>! 
 XRAY>! Requirements: 
 XRAY>!    Needs to be called within xray 
 XRAY> 
 XRAY>module {calculate_r} 
 MODULE-DECLARATION> 
 MODULE-DECLARATION>( 
 MODULE-DECLARATION>&fobs=fobs; 
 MODULE-DECLARATION>&fcalc=fcalc; 
 MODULE-DECLARATION>&fpart=fpart; 
 MODULE-DECLARATION>&sel=all; 
 MODULE-DECLARATION>&sel_test=none; 
 MODULE-DECLARATION> 
 MODULE-DECLARATION>&print=false;  ! if true, writes R value distributions as a function of resolution to the file specified by "&output" 
 MODULE-DECLARATION>               ! if false, only writes the overall R values to &output 
 MODULE-DECLARATION> 
 MODULE-DECLARATION>&output=OUTPUT; 
 MODULE-DECLARATION>&r=$r; 
 MODULE-DECLARATION>&test_r=$test_r; 
 MODULE-DECLARATION> 
 MODULE-DECLARATION>&calc_r_stats=false; !flag indicating to compute compound symbol that contains the R value distribution and completeness 
 MODULE-DECLARATION>&r_stats=$r_stats;   !compound symbol that contains R value distributions and completeness 
 MODULE-DECLARATION>!  r_stats.nbins           ! number of bins 
 MODULE-DECLARATION>!  r_stats.<i>.high        ! high resolution limit for bin <i> 
 MODULE-DECLARATION>!  r_stats.<i>.low         ! low resolution limit for bin <i> 
 MODULE-DECLARATION>!  r_stats.<i>.nref_work   ! number of reflections in working set for bin <i> 
 MODULE-DECLARATION>!  r_stats.<i>.nref_free   ! number of reflections in test set for bin <i> 
 MODULE-DECLARATION>!  r_stats.<i>.value_comp  ! completeness (work + test set) for bin <i> 
 MODULE-DECLARATION>!  r_stats.<i>.value_work  ! working R value for bin <i> 
 MODULE-DECLARATION>!  r_stats.<i>.value_free  ! free R value for bin <i> 
 MODULE-DECLARATION> 
 MODULE-DECLARATION>) 
 MODULE-INVOCATION>                                 fobs=&STRIP%obs_f; 
 &_2_FOBS set to &STRIP%_1_OBS_F 
 MODULE-INVOCATION>                                 fcalc=fcalc; 
 &_2_FCALC set to fcalc 
 MODULE-INVOCATION>                                 fpart=fbulk; 
 &_2_FPART set to fbulk 
 MODULE-INVOCATION>                                 sel=( ref_active=1 ); 
 &_2_SEL set to ( ref_active = 1 ) 
 MODULE-INVOCATION>                                 sel_test=( tst_active=1 ); 
 &_2_SEL_TEST set to ( tst_active = 1 ) 
 MODULE-INVOCATION>                                 print=true; 
 &_2_PRINT set to true 
 MODULE-INVOCATION>                                 output=OUTPUT; 
 &_2_OUTPUT set to OUTPUT 
 MODULE-INVOCATION>                                 r=$start_r; 
 &_2_R set to $_1_START_R 
 MODULE-INVOCATION>                                 test_r=$start_test_r;) 
 &_2_TEST_R set to $_1_START_TEST_R 
 XRAY> 
 XRAY>set message ? end 
 MESSage=NORM
 XRAY>evaluate ($message_old=$result) 
 EVALUATE: symbol $MESSAGE_OLD set to "NORM" (string)
 XRAY>set echo ? end 
 ECHO=TRUE {ON}
 XRAY>evaluate ($echo_old=$result) 
 EVALUATE: symbol $ECHO_OLD set to TRUE (logical)
 XRAY>if ( $log_level = verbose ) then 
 NEXTCD: condition evaluated as false
 XRAY>  set echo=on message=normal end 
 XRAY>else 
 XRAY>  set echo=off message=off end 
============================================
     R-value by resolution for test set
============================================
 #bin | resolution range | #refl | 
    1   4.36   40.62         85      0.2244
    2   3.46    4.36         65      0.2154
    3   3.02    3.46         63      0.2587
    4   2.75    3.02         55      0.2745
    5   2.55    2.75         60      0.3434
    6   2.40    2.55         52      0.3069
    7   2.28    2.40         49      0.3613
    8   2.18    2.28         47      0.2966
>>>> Overall R-value for test set: 0.262259
============================================
    R-value by resolution for working set
============================================
 #bin | resolution range | #refl | 
    1   4.36   40.62        852      0.2029
    2   3.46    4.36        820      0.1720
    3   3.02    3.46        800      0.2293
    4   2.75    3.02        773      0.2647
    5   2.55    2.75        711      0.2854
    6   2.40    2.55        668      0.2828
    7   2.28    2.40        614      0.2946
    8   2.18    2.28        547      0.3172
>>>> Overall R-value for working set: 0.233249
 XRAY> end 
 CNSsolve> 
 CNSsolve> {- check the gridding again since the minimum B-factor may have changed -} 
 CNSsolve> show min ( b ) ( &atom_select ) 
 SELRPN:   1240 atoms have been selected out of   1240
 SHOW: minimum of selected elements =       1.923358
 CNSsolve> evaluate ($b_min=$result) 
 EVALUATE: symbol $B_MIN set to    1.92336     (real)
 CNSsolve> @@CNS_XTALMODULE:fft_parameter_check ( 
 ASSFIL: file fft_parameter_check opened.
 CNSsolve>! Module file: fft_parameter_check 
 CNSsolve>! 
 CNSsolve>! Function: determines the optimum setting for the B-factor inflation 
 CNSsolve>! given the high resolution limit, the gridding factor, and the minimum 
 CNSsolve>! B-factor of the model.   It also determines the recommended ELIM parameter 
 CNSsolve>! as a function of the high resolution limit. 
 CNSsolve>! 
 CNSsolve>! Reference: 
 CNSsolve>! 
 CNSsolve>! Gerard Bricogne (2001), 
 CNSsolve>!   International Tables for Crystallography, Volume B, 2001, p. 87 
 CNSsolve>! 
 CNSsolve>! CNS module 
 CNSsolve>! ********** 
 CNSsolve>! 
 CNSsolve>! Authors: Axel T. Brunger and Paul D. Adams 
 CNSsolve>! 
 CNSsolve>! copyright Yale University 
 CNSsolve>! 
 CNSsolve>! Requirements: 
 CNSsolve>! This module can only be used from the main level of CNS. 
 CNSsolve>! 
 CNSsolve>! 08/03/06 ATB 
 CNSsolve> 
 CNSsolve>module {fft_parameter_check} 
 MODULE-DECLARATION>( 
 MODULE-DECLARATION> &b_min=0;              {input: minimum B-factor of model} 
 MODULE-DECLARATION> &d_min=1.0;            {input: high resolution limit} 
 MODULE-DECLARATION> &q_factor=100;         {input: quality factor - 100 for 1% accuracy} 
 MODULE-DECLARATION> &grid=auto;            {input: if "auto" gridding factor is set automatically} 
 MODULE-DECLARATION>                        {       otherwise gridding factor set to <number>  } 
 MODULE-DECLARATION> &fft_memory=-1;        {input: fft memory; if "-1" use automatic mode } 
 MODULE-DECLARATION> 
 MODULE-DECLARATION> &fft_grid=$fft_grid;   {output: fft gridding factor} 
 MODULE-DECLARATION> &fft_b_add=$fft_b_add; {output: fft B addition} 
 MODULE-DECLARATION> &fft_elim=$fft_elim;   {output: fft elimit factor} 
 MODULE-DECLARATION> 
 MODULE-DECLARATION>) 
 MODULE-INVOCATION>                             d_min=&high_res; 
 &_2_D_MIN set to &_1_HIGH_RES 
 MODULE-INVOCATION>                             b_min=$b_min; 
 &_2_B_MIN set to $_1_B_MIN 
 MODULE-INVOCATION>                             grid=auto; 
 &_2_GRID set to auto 
 MODULE-INVOCATION>                             fft_memory=&fft_memory; 
 &_2_FFT_MEMORY set to &_1_FFT_MEMORY 
 MODULE-INVOCATION>                             fft_grid=$fft_grid; 
 &_2_FFT_GRID set to $_1_FFT_GRID 
 MODULE-INVOCATION>                             fft_b_add=$fft_b_add; 
 &_2_FFT_B_ADD set to $_1_FFT_B_ADD 
 MODULE-INVOCATION>                             fft_elim=$fft_elim; 
 &_2_FFT_ELIM set to $_1_FFT_ELIM 
 MODULE-INVOCATION>                                      ) 
 CNSsolve> 
 CNSsolve> set message ? end 
 MESSage=NORM
 CNSsolve> evaluate ($message_old=$result) 
 EVALUATE: symbol $MESSAGE_OLD set to "NORM" (string)
 CNSsolve> set echo ? end 
 ECHO=TRUE {ON}
 CNSsolve> evaluate ($echo_old=$result) 
 EVALUATE: symbol $ECHO_OLD set to TRUE (logical)
 CNSsolve> if ( $log_level = verbose ) then 
 NEXTCD: condition evaluated as false
 CNSsolve>   set echo=on message=normal end 
 CNSsolve> else 
 CNSsolve>   set echo=off message=off end 
 XRMAPR: symmetry or unitcell changed. Real space obj. deleted.
 fft_parameter_check: using automatic memory option
 fft_parameter_check: minimum model B-factor = 1.92336  A^2
 fft_parameter_check: high resolution limit = 2.18  A
 fft_parameter_check: fft gridding factor set to 0.3333
 fft_parameter_check: fft B factor offset set to 10.7446  A^2
 fft_parameter_check: fft Elimit factor set to 8
 CNSsolve> 
 CNSsolve>{- END MODIFICATION -} 
 CNSsolve> 
 CNSsolve> if ( $harmonic = true ) then 
 NEXTCD: condition evaluated as false
 CNSsolve>   do (refx=x) (all) 
 CNSsolve>   do (refy=y) (all) 
 CNSsolve>   do (refz=z) (all) 
 CNSsolve>   do (harm=0) (all) 
 CNSsolve>   do (harm=&k_harmonic) (&atom_harm) 
 CNSsolve>   flags include harm end 
 CNSsolve> end if 
 CNSsolve> 
 CNSsolve> 
 CNSsolve> evaluate ($cycle=1) 
 EVALUATE: symbol $CYCLE set to    1.00000     (real)
 CNSsolve> 
 CNSsolve> while ($cycle <= &num_cycles) loop main 
 NEXTCD: condition evaluated as true
 CNSsolve> 
 CNSsolve>   xray 
 XRAY>     @@CNS_XTALMODULE:refinementtarget (target=&reftarget; 
 ASSFIL: file refinementtarget opened.
 XRAY>! Module file: refinementtarget 
 XRAY>! 
 XRAY>! CNS module 
 XRAY>! ********** 
 XRAY>! 
 XRAY>! Authors: Axel Brunger and Paul Adams 
 XRAY>! 
 XRAY>! copyright Yale University 
 XRAY>! 
 XRAY>! Function: 
 XRAY>!    Defines the crystallographic refinement targets 
 XRAY>! 
 XRAY>! Requirements: 
 XRAY>!    Needs to be called within xray 
 XRAY> 
 XRAY>module {refinementtarget} 
 MODULE-DECLARATION> 
 MODULE-DECLARATION>( 
 MODULE-DECLARATION>  &target="residual";    {string} 
 MODULE-DECLARATION>  &sig_sigacv=0.07;      {real} 
 MODULE-DECLARATION>  &mbins=10;             {real} 
 MODULE-DECLARATION>  &fobs=fobs;            {reciprocal space array} 
 MODULE-DECLARATION>  &sigma=sigma;          {reciprocal space array} 
 MODULE-DECLARATION>  &weight=weight;        {reciprocal space array} 
 MODULE-DECLARATION>  &iobs=iobs;            {reciprocal space array} 
 MODULE-DECLARATION>  &sigi=sigi;            {reciprocal space array} 
 MODULE-DECLARATION>  &test=test;            {reciprocal space array} 
 MODULE-DECLARATION>  &fcalc=fcalc;          {reciprocal space array} 
 MODULE-DECLARATION>  &fpart=fpart;          {reciprocal space array} 
 MODULE-DECLARATION>  &pa=pa;                {reciprocal space array} 
 MODULE-DECLARATION>  &pb=pb;                {reciprocal space array} 
 MODULE-DECLARATION>  &pc=pc;                {reciprocal space array} 
 MODULE-DECLARATION>  &pd=pd;                {reciprocal space array} 
 MODULE-DECLARATION>  &phase=phase;          {reciprocal space array} 
 MODULE-DECLARATION>  &fom=fom;              {reciprocal space array} 
 MODULE-DECLARATION>  &sel=all;              {selection} 
 MODULE-DECLARATION>  &sel_test=none;        {selection} 
 MODULE-DECLARATION>  &statistics=false;     {logical} 
 MODULE-DECLARATION>) 
 &_2_TARGET set to &_1_REFTARGET 
 MODULE-INVOCATION>                                       sig_sigacv=0.07; 
 &_2_SIG_SIGACV set to 0.07 
 MODULE-INVOCATION>                                       mbins=&target_bins; 
 &_2_MBINS set to &_1_TARGET_BINS 
 MODULE-INVOCATION>                                       fobs=&STRIP%obs_f; 
 &_2_FOBS set to &STRIP%_1_OBS_F 
 MODULE-INVOCATION>                                       sigma=&STRIP%obs_sigf; 
 &_2_SIGMA set to &STRIP%_1_OBS_SIGF 
 MODULE-INVOCATION>                                       weight=$STRIP%obs_w; 
 &_2_WEIGHT set to $STRIP%_1_OBS_W 
 MODULE-INVOCATION>                                       iobs=$STRIP%obs_i; 
 &_2_IOBS set to $STRIP%_1_OBS_I 
 MODULE-INVOCATION>                                       sigi=$STRIP%obs_sigi; 
 &_2_SIGI set to $STRIP%_1_OBS_SIGI 
 MODULE-INVOCATION>                                       test=tst_active; 
 &_2_TEST set to tst_active 
 MODULE-INVOCATION>                                       fcalc=fcalc; 
 &_2_FCALC set to fcalc 
 MODULE-INVOCATION>                                       fpart=fbulk; 
 &_2_FPART set to fbulk 
 MODULE-INVOCATION>                                       pa=&STRIP%obs_pa; 
 &_2_PA set to &STRIP%_1_OBS_PA 
 MODULE-INVOCATION>                                       pb=&STRIP%obs_pb; 
 &_2_PB set to &STRIP%_1_OBS_PB 
 MODULE-INVOCATION>                                       pc=&STRIP%obs_pc; 
 &_2_PC set to &STRIP%_1_OBS_PC 
 MODULE-INVOCATION>                                       pd=&STRIP%obs_pd; 
 &_2_PD set to &STRIP%_1_OBS_PD 
 MODULE-INVOCATION>                                       phase=&STRIP%obs_phase; 
 &_2_PHASE set to &STRIP%_1_OBS_PHASE 
 MODULE-INVOCATION>                                       fom=&STRIP%obs_fom; 
 &_2_FOM set to &STRIP%_1_OBS_FOM 
 MODULE-INVOCATION>                                       sel=(ref_active=1); 
 &_2_SEL set to ( ref_active = 1 ) 
 MODULE-INVOCATION>                                       sel_test=(tst_active=1); 
 &_2_SEL_TEST set to ( tst_active = 1 ) 
 MODULE-INVOCATION>                                       statistics=true;) 
 &_2_STATISTICS set to true 
 XRAY> 
 XRAY>set message ? end 
 MESSage=NORM
 XRAY>evaluate ($message_old=$result) 
 EVALUATE: symbol $MESSAGE_OLD set to "NORM" (string)
 XRAY>set echo ? end 
 ECHO=TRUE {ON}
 XRAY>evaluate ($echo_old=$result) 
 EVALUATE: symbol $ECHO_OLD set to TRUE (logical)
 XRAY>if ( $log_level = verbose ) then 
 NEXTCD: condition evaluated as false
 XRAY>  set echo=on message=normal end 
 XRAY>else 
 XRAY>  set echo=off message=off end 
 XSIGMAACV: Overall sigma for line restraint is       0.07000000
 XSIGMAACV: gradient converged
 XSIGMAACV: Refinement of SIGMAA has converged 
            Overall mean FOM is   0.79339

 sigmaA statistics                   sigmaA   sigmaD     Delta     <Eobs^2>  <Ecalc^2>
 #bin | resolution range | #refl | 
    1   4.53   40.62        839      0.9515   79.5405    0.7736    0.9964    0.9968
    2   3.60    4.53        789      0.9579   85.1713    0.8457    0.9991    0.9991
    3   3.14    3.60        774      0.9473   68.0369    0.8676    0.9993    0.9986
    4   2.86    3.14        742      0.8869   72.5695    0.7690    0.9984    0.9993
    5   2.65    2.86        712      0.8900   70.2408    0.8180    0.9995    1.0000
    6   2.50    2.65        664      0.8167   65.9180    0.6954    0.9985    0.9993
    7   2.37    2.50        633      0.8743   55.2424    0.7005    0.9993    0.9997
    8   2.27    2.37        586      0.8610   50.8005    0.6904    0.9995    0.9992
    9   2.18    2.27        522      0.8539   60.2598    0.8024    1.0000    1.0000
 XRAY>   end 
 CNSsolve> 
 CNSsolve>   if ( &wa < 0 ) then 
 NEXTCD: condition evaluated as false
 CNSsolve>     @@CNS_XTALMODULE:getweight ( 
 CNSsolve>                                selected=&atom_select; 
 CNSsolve>                                fixed=(store9); 
 CNSsolve>                               ) 
 CNSsolve>   end if 
 CNSsolve> 
 CNSsolve>   if ( &minimize_nstep > 0 ) then 
 NEXTCD: condition evaluated as false
 CNSsolve>     minimize lbfgs 
 CNSsolve>       nstep=&minimize_nstep 
 CNSsolve>       nprint=5 
 CNSsolve>       drop=10.0 
 CNSsolve>     end 
 CNSsolve>   end if 
 CNSsolve> 
 CNSsolve>   evaluate ($cycle=$cycle+1) 
 EVALUATE: symbol $CYCLE set to    2.00000     (real)
 CNSsolve> 
 CNSsolve> end loop main 
 CNSsolve> while ($cycle <= &num_cycles) loop main 
 NEXTCD: condition evaluated as false
 CNSsolve> 
 CNSsolve>   xray 
 CNSsolve>     @@CNS_XTALMODULE:refinementtarget (target=&reftarget; 
 CNSsolve>                                       sig_sigacv=0.07; 
 CNSsolve>                                       mbins=&target_bins; 
 CNSsolve>                                       fobs=&STRIP%obs_f; 
 CNSsolve>                                       sigma=&STRIP%obs_sigf; 
 CNSsolve>                                       weight=$STRIP%obs_w; 
 CNSsolve>                                       iobs=$STRIP%obs_i; 
 CNSsolve>                                       sigi=$STRIP%obs_sigi; 
 CNSsolve>                                       test=tst_active; 
 CNSsolve>                                       fcalc=fcalc; 
 CNSsolve>                                       fpart=fbulk; 
 CNSsolve>                                       pa=&STRIP%obs_pa; 
 CNSsolve>                                       pb=&STRIP%obs_pb; 
 CNSsolve>                                       pc=&STRIP%obs_pc; 
 CNSsolve>                                       pd=&STRIP%obs_pd; 
 CNSsolve>                                       phase=&STRIP%obs_phase; 
 CNSsolve>                                       fom=&STRIP%obs_fom; 
 CNSsolve>                                       sel=(ref_active=1); 
 CNSsolve>                                       sel_test=(tst_active=1); 
 CNSsolve>                                       statistics=true;) 
 CNSsolve>   end 
 CNSsolve> 
 CNSsolve>   if ( &wa < 0 ) then 
 CNSsolve>     @@CNS_XTALMODULE:getweight ( 
 CNSsolve>                                selected=&atom_select; 
 CNSsolve>                                fixed=(store9); 
 CNSsolve>                               ) 
 CNSsolve>   end if 
 CNSsolve> 
 CNSsolve>   if ( &minimize_nstep > 0 ) then 
 CNSsolve>     minimize lbfgs 
 CNSsolve>       nstep=&minimize_nstep 
 CNSsolve>       nprint=5 
 CNSsolve>       drop=10.0 
 CNSsolve>     end 
 CNSsolve>   end if 
 CNSsolve> 
 CNSsolve>   evaluate ($cycle=$cycle+1) 
 CNSsolve> 
 CNSsolve> end loop main 
 CNSsolve> 
 CNSsolve> xray 
 XRAY>    predict 
 PREDict>      mode=reciprocal 
 PREDict>      to=fcalc 
 PREDict>      selection=(ref_active=1) 
 Total of      6261 structure factor elements were selected.
 PREDict>      atomselection=( &atom_select ) 
 SELRPN:   1240 atoms have been selected out of   1240
 PREDict>    end 
 FCALC: #scatt.=   1240 #anomalous=   0 #special pos.=  0 occupancies=1
 XFFT: using grid [  48,  72, 108] and sublattice [  48(  49),  72(  73), 108]
 XRAY>    @@CNS_XTALMODULE:calculate_r (fobs=&STRIP%obs_f; 
 ASSFIL: file calculate_r opened.
 XRAY>! Module file: calculate_r 
 XRAY>! 
 XRAY>! CNS module 
 XRAY>! ************ 
 XRAY>! 
 XRAY>! Authors: Axel Brunger and Paul Adams 
 XRAY>! 
 XRAY>! copyright Yale University 
 XRAY>! 
 XRAY>! Function: 
 XRAY>!    Calculates crystallographic R-values 
 XRAY>! 
 XRAY>! Requirements: 
 XRAY>!    Needs to be called within xray 
 XRAY> 
 XRAY>module {calculate_r} 
 MODULE-DECLARATION> 
 MODULE-DECLARATION>( 
 MODULE-DECLARATION>&fobs=fobs; 
 MODULE-DECLARATION>&fcalc=fcalc; 
 MODULE-DECLARATION>&fpart=fpart; 
 MODULE-DECLARATION>&sel=all; 
 MODULE-DECLARATION>&sel_test=none; 
 MODULE-DECLARATION> 
 MODULE-DECLARATION>&print=false;  ! if true, writes R value distributions as a function of resolution to the file specified by "&output" 
 MODULE-DECLARATION>               ! if false, only writes the overall R values to &output 
 MODULE-DECLARATION> 
 MODULE-DECLARATION>&output=OUTPUT; 
 MODULE-DECLARATION>&r=$r; 
 MODULE-DECLARATION>&test_r=$test_r; 
 MODULE-DECLARATION> 
 MODULE-DECLARATION>&calc_r_stats=false; !flag indicating to compute compound symbol that contains the R value distribution and completeness 
 MODULE-DECLARATION>&r_stats=$r_stats;   !compound symbol that contains R value distributions and completeness 
 MODULE-DECLARATION>!  r_stats.nbins           ! number of bins 
 MODULE-DECLARATION>!  r_stats.<i>.high        ! high resolution limit for bin <i> 
 MODULE-DECLARATION>!  r_stats.<i>.low         ! low resolution limit for bin <i> 
 MODULE-DECLARATION>!  r_stats.<i>.nref_work   ! number of reflections in working set for bin <i> 
 MODULE-DECLARATION>!  r_stats.<i>.nref_free   ! number of reflections in test set for bin <i> 
 MODULE-DECLARATION>!  r_stats.<i>.value_comp  ! completeness (work + test set) for bin <i> 
 MODULE-DECLARATION>!  r_stats.<i>.value_work  ! working R value for bin <i> 
 MODULE-DECLARATION>!  r_stats.<i>.value_free  ! free R value for bin <i> 
 MODULE-DECLARATION> 
 MODULE-DECLARATION>) 
 &_2_FOBS set to &STRIP%_1_OBS_F 
 MODULE-INVOCATION>                                 fcalc=fcalc; 
 &_2_FCALC set to fcalc 
 MODULE-INVOCATION>                                 fpart=fbulk; 
 &_2_FPART set to fbulk 
 MODULE-INVOCATION>                                 sel=(ref_active=1); 
 &_2_SEL set to ( ref_active = 1 ) 
 MODULE-INVOCATION>                                 sel_test=(tst_active=1); 
 &_2_SEL_TEST set to ( tst_active = 1 ) 
 MODULE-INVOCATION>                                 print=true; 
 &_2_PRINT set to true 
 MODULE-INVOCATION>                                 output=OUTPUT; 
 &_2_OUTPUT set to OUTPUT 
 MODULE-INVOCATION>                                 r=$full_r; 
 &_2_R set to $_1_FULL_R 
 MODULE-INVOCATION>                                 test_r=$full_test_r;) 
 &_2_TEST_R set to $_1_FULL_TEST_R 
 XRAY> 
 XRAY>set message ? end 
 MESSage=NORM
 XRAY>evaluate ($message_old=$result) 
 EVALUATE: symbol $MESSAGE_OLD set to "NORM" (string)
 XRAY>set echo ? end 
 ECHO=TRUE {ON}
 XRAY>evaluate ($echo_old=$result) 
 EVALUATE: symbol $ECHO_OLD set to TRUE (logical)
 XRAY>if ( $log_level = verbose ) then 
 NEXTCD: condition evaluated as false
 XRAY>  set echo=on message=normal end 
 XRAY>else 
 XRAY>  set echo=off message=off end 
============================================
     R-value by resolution for test set
============================================
 #bin | resolution range | #refl | 
    1   4.53   40.62         79      0.2269
    2   3.60    4.53         54      0.2134
    3   3.14    3.60         55      0.2232
    4   2.86    3.14         58      0.3192
    5   2.65    2.86         46      0.2817
    6   2.50    2.65         51      0.3540
    7   2.37    2.50         52      0.2966
    8   2.27    2.37         38      0.3628
    9   2.18    2.27         43      0.2903
>>>> Overall R-value for test set: 0.262259
============================================
    R-value by resolution for working set
============================================
 #bin | resolution range | #refl | 
    1   4.53   40.62        760      0.2062
    2   3.60    4.53        735      0.1704
    3   3.14    3.60        719      0.2122
    4   2.86    3.14        684      0.2547
    5   2.65    2.86        666      0.2738
    6   2.50    2.65        613      0.2869
    7   2.37    2.50        581      0.2924
    8   2.27    2.37        548      0.2859
    9   2.18    2.27        479      0.3254
>>>> Overall R-value for working set: 0.233249
 XRAY> end 
 CNSsolve> 
 CNSsolve>{GAUCNS Set flags} 
 CNSsolve>set echo=off message=off end 
 EFLAGS: the following energy flags are set
 EFLAGS: XREF
 XTAREXPR: ->[TEST SET]    monitor=  0.262
 XTAREXPR: ->[WORKING SET] monitor=  0.233
 --------------- cycle=     1 --------------------------------------------------
 | Etotal =44449.988  grad(E)=7.962      E(XREF)=44449.988                     |
 -------------------------------------------------------------------------------
 (atom-i        |atom-j        )    dist.   equil.   delta    energy   const. 

 Number of violations greater   20.000:     0
 RMS deviation=   0.013
 EVALUATE: symbol $RMSD_BOND set to   0.131966E-01 (real)
 (atom-i        |atom-j        |atom-k        )  angle    equil.     delta    energy  const. 

 Number of violations greater   50.000:     0
 RMS deviation=   1.522
 EVALUATE: symbol $RMSD_ANGLE set to    1.52213     (real)
 ASSFIL: file minimize.pdb opened.
 NEXTCD: condition evaluated as true
 WA=  1.7995    
 EVALUATE: symbol $WA_PRINT set to    1.79950     (real)
 EVALUATE: symbol $COUNTER set to    1.00000     (real)
 EVALUATE: symbol $DONE set to FALSE (logical)
 NEXTCD: condition evaluated as true
 NEXTCD: condition evaluated as true
 NEXTCD: condition evaluated as true
 EVALUATE: symbol $COUNTER set to    2.00000     (real)
 NEXTCD: condition evaluated as true
 NEXTCD: condition evaluated as true
 NEXTCD: condition evaluated as true
 EVALUATE: symbol $COUNTER set to    3.00000     (real)
 NEXTCD: condition evaluated as true
 NEXTCD: condition evaluated as true
 NEXTCD: condition evaluated as true
 EVALUATE: symbol $COUNTER set to    4.00000     (real)
 NEXTCD: condition evaluated as true
 NEXTCD: condition evaluated as true
 NEXTCD: condition evaluated as true
 EVALUATE: symbol $COUNTER set to    5.00000     (real)
 NEXTCD: condition evaluated as true
 NEXTCD: condition evaluated as true
 NEXTCD: condition evaluated as true
 EVALUATE: symbol $COUNTER set to    6.00000     (real)
 NEXTCD: condition evaluated as true
 NEXTCD: condition evaluated as true
 NEXTCD: condition evaluated as true
 EVALUATE: symbol $COUNTER set to    7.00000     (real)
 NEXTCD: condition evaluated as true
 NEXTCD: condition evaluated as true
 NEXTCD: condition evaluated as false
 EVALUATE: symbol $COUNTER set to    8.00000     (real)
 NEXTCD: condition evaluated as true
 NEXTCD: condition evaluated as true
 NEXTCD: condition evaluated as false
 EVALUATE: symbol $COUNTER set to    9.00000     (real)
 NEXTCD: condition evaluated as true
 NEXTCD: condition evaluated as false
 EVALUATE: symbol $DONE set to TRUE (logical)
 EVALUATE: symbol $COUNTER set to    10.0000     (real)
 NEXTCD: condition evaluated as false
 NEXTCD: condition evaluated as false
 NEXTCD: condition evaluated as false
 EVALUATE: symbol $COUNTER set to    1.00000     (real)
 EVALUATE: symbol $DONE set to FALSE (logical)
 NEXTCD: condition evaluated as true
 NEXTCD: condition evaluated as true
 NEXTCD: condition evaluated as true
 EVALUATE: symbol $COUNTER set to    2.00000     (real)
 NEXTCD: condition evaluated as true
 NEXTCD: condition evaluated as true
 NEXTCD: condition evaluated as false
 EVALUATE: symbol $COUNTER set to    3.00000     (real)
 NEXTCD: condition evaluated as true
 NEXTCD: condition evaluated as true
 NEXTCD: condition evaluated as false
 EVALUATE: symbol $COUNTER set to    4.00000     (real)
 NEXTCD: condition evaluated as true
 NEXTCD: condition evaluated as true
 NEXTCD: condition evaluated as false
 EVALUATE: symbol $COUNTER set to    5.00000     (real)
 NEXTCD: condition evaluated as true
 NEXTCD: condition evaluated as false
 EVALUATE: symbol $DONE set to TRUE (logical)
 EVALUATE: symbol $COUNTER set to    6.00000     (real)
 NEXTCD: condition evaluated as false
 NEXTCD: condition evaluated as false
 NEXTCD: condition evaluated as false
 NEXTCD: condition evaluated as true
 NEXTCD: condition evaluated as false
 NEXTCD: condition evaluated as false
 NEXTCD: condition evaluated as true
 NEXTCD: condition evaluated as true
 NEXTCD: condition evaluated as false
 ANOMalous=FALSe {OFF}
 NEXTCD: condition evaluated as false
 SELRPN:   1240 atoms have been selected out of   1240
 SELRPN:   1240 atoms have been selected out of   1240
 SELRPN:   1240 atoms have been selected out of   1240
 SELRPN:   1240 atoms have been selected out of   1240
 SELRPN:   1240 atoms have been selected out of   1240
 SELRPN:   1240 atoms have been selected out of   1240
 SELRPN:   1240 atoms have been selected out of   1240
 SELRPN:   1240 atoms have been selected out of   1240
 SELRPN:   1240 atoms have been selected out of   1240
 ASSFIL: file write_pdb opened.
 &_2_PDB_O_FORMAT set to true 
 &_2_COORDINATE_OUTFILE set to &_1_COORDINATE_OUTFILE 
 &_2_SGPARAM set to $_1_SGPARAM 
 NEXTCD: condition evaluated as true
 ASSFIL: file pdbgetsgname opened.
 &_3_SG set to &_2_SGPARAM.SG_NUMBER 
 &_3_SGNAME set to $_2_SG_PDB 
 MESSage=NORM
 EVALUATE: symbol $MESSAGE_OLD set to "NORM" (string)
 ECHO=FALSe {OFF}
 EVALUATE: symbol $ECHO_OLD set to FALSE (logical)
 NEXTCD: condition evaluated as false
 DISPlay-file=minimize.pdb
 EVALUATE: symbol $CURR_DISPLAY set to "minimize.pdb" (string)
 SELRPN:   1240 atoms have been selected out of   1240
 VCLOSE: Display file reset to OUTPUT.
 ASSFIL: file minimize.pdb1 opened.
 NEXTCD: condition evaluated as true
 WA=  1.7995    
 EVALUATE: symbol $WA_PRINT set to    1.79950     (real)
 EVALUATE: symbol $COUNTER set to    1.00000     (real)
 EVALUATE: symbol $DONE set to FALSE (logical)
 NEXTCD: condition evaluated as true
 NEXTCD: condition evaluated as true
 NEXTCD: condition evaluated as true
 EVALUATE: symbol $COUNTER set to    2.00000     (real)
 NEXTCD: condition evaluated as true
 NEXTCD: condition evaluated as true
 NEXTCD: condition evaluated as true
 EVALUATE: symbol $COUNTER set to    3.00000     (real)
 NEXTCD: condition evaluated as true
 NEXTCD: condition evaluated as true
 NEXTCD: condition evaluated as true
 EVALUATE: symbol $COUNTER set to    4.00000     (real)
 NEXTCD: condition evaluated as true
 NEXTCD: condition evaluated as true
 NEXTCD: condition evaluated as true
 EVALUATE: symbol $COUNTER set to    5.00000     (real)
 NEXTCD: condition evaluated as true
 NEXTCD: condition evaluated as true
 NEXTCD: condition evaluated as true
 EVALUATE: symbol $COUNTER set to    6.00000     (real)
 NEXTCD: condition evaluated as true
 NEXTCD: condition evaluated as true
 NEXTCD: condition evaluated as true
 EVALUATE: symbol $COUNTER set to    7.00000     (real)
 NEXTCD: condition evaluated as true
 NEXTCD: condition evaluated as true
 NEXTCD: condition evaluated as false
 EVALUATE: symbol $COUNTER set to    8.00000     (real)
 NEXTCD: condition evaluated as true
 NEXTCD: condition evaluated as true
 NEXTCD: condition evaluated as false
 EVALUATE: symbol $COUNTER set to    9.00000     (real)
 NEXTCD: condition evaluated as true
 NEXTCD: condition evaluated as false
 EVALUATE: symbol $DONE set to TRUE (logical)
 EVALUATE: symbol $COUNTER set to    10.0000     (real)
 NEXTCD: condition evaluated as false
 NEXTCD: condition evaluated as false
 NEXTCD: condition evaluated as false
 EVALUATE: symbol $COUNTER set to    1.00000     (real)
 EVALUATE: symbol $DONE set to FALSE (logical)
 NEXTCD: condition evaluated as true
 NEXTCD: condition evaluated as true
 NEXTCD: condition evaluated as true
 EVALUATE: symbol $COUNTER set to    2.00000     (real)
 NEXTCD: condition evaluated as true
 NEXTCD: condition evaluated as true
 NEXTCD: condition evaluated as false
 EVALUATE: symbol $COUNTER set to    3.00000     (real)
 NEXTCD: condition evaluated as true
 NEXTCD: condition evaluated as true
 NEXTCD: condition evaluated as false
 EVALUATE: symbol $COUNTER set to    4.00000     (real)
 NEXTCD: condition evaluated as true
 NEXTCD: condition evaluated as true
 NEXTCD: condition evaluated as false
 EVALUATE: symbol $COUNTER set to    5.00000     (real)
 NEXTCD: condition evaluated as true
 NEXTCD: condition evaluated as false
 EVALUATE: symbol $DONE set to TRUE (logical)
 EVALUATE: symbol $COUNTER set to    6.00000     (real)
 NEXTCD: condition evaluated as false
 NEXTCD: condition evaluated as false
 NEXTCD: condition evaluated as false
 NEXTCD: condition evaluated as true
 NEXTCD: condition evaluated as false
 NEXTCD: condition evaluated as false
 NEXTCD: condition evaluated as true
 NEXTCD: condition evaluated as true
 NEXTCD: condition evaluated as false
 ANOMalous=FALSe {OFF}
 NEXTCD: condition evaluated as false
 SELRPN:   1240 atoms have been selected out of   1240
 SELRPN:   1240 atoms have been selected out of   1240
 SELRPN:   1240 atoms have been selected out of   1240
 ASSFIL: file write_pdb opened.
 &_2_PDB_O_FORMAT set to true 
 &_2_COORDINATE_OUTFILE set to minimize.pdb1 
 &_2_SGPARAM set to $_1_SGPARAM 
 NEXTCD: condition evaluated as true
 ASSFIL: file pdbgetsgname opened.
 &_3_SG set to &_2_SGPARAM.SG_NUMBER 
 &_3_SGNAME set to $_2_SG_PDB 
 MESSage=NORM
 EVALUATE: symbol $MESSAGE_OLD set to "NORM" (string)
 ECHO=FALSe {OFF}
 EVALUATE: symbol $ECHO_OLD set to FALSE (logical)
 NEXTCD: condition evaluated as false
 DISPlay-file=minimize.pdb1
 EVALUATE: symbol $CURR_DISPLAY set to "minimize.pdb1" (string)
 SELRPN:   1240 atoms have been selected out of   1240
 VCLOSE: Display file reset to OUTPUT.
          ============================================================
           Maximum dynamic memory allocation:    19325152 bytes
           Maximum dynamic memory overhead:          1120 bytes
           Program started at: 12:03:19 on 27-Nov-2023
           Program stopped at: 12:03:21 on 27-Nov-2023
           CPU time used:       1.4884 seconds
          ============================================================
