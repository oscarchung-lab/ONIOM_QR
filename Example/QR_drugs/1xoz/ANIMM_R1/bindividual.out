          ============================================================
          |                                                          |
          |            Crystallography & NMR System (CNS)            |
          |                         CNSsolve                         |
          |                                                          |
          ============================================================
           Version: 1.3
           Status: General release
          ============================================================
           Written by: A.T.Brunger, P.D.Adams, G.M.Clore, W.L.DeLano,
                       P.Gros, R.W.Grosse-Kunstleve,J.-S.Jiang,J.M.Krahn,
                       J.Kuszewski, M.Nilges, N.S.Pannu, R.J.Read,
                       L.M.Rice, G.F.Schroeder, T.Simonson, G.L.Warren.
           Copyright (c) 1997-2010 Yale University
          ============================================================
           Running on machine: hostname unknown (x86_64/Linux,64-bit)
           Program started by: yanz
           Program started at: 20:41:25 on 19-Dec-2023
          ============================================================

 FFT3C: Using FFTPACK4.1

 CNSsolve>{+ file: bindividual.inp +} 
 CNSsolve>{+ directory: xtal_refine +} 
 CNSsolve>{+ description: Restrained, individual B-factor refinement +} 
 CNSsolve>{+ authors: Axel T. Brunger, and Paul D. Adams +} 
 CNSsolve>{+ copyright: Yale University +} 
 CNSsolve> 
 CNSsolve>{+ reference: A.T. Brunger, The Free R Value: a Novel Statistical 
 CNSsolve>              Quantity for Assessing the Accuracy of Crystal Structures, 
 CNSsolve>              Nature 355, 472-474 (1992) +} 
 CNSsolve>{+ reference: N.S. Pannu and R.J. Read, Improved structure refinement 
 CNSsolve>              through maximum likelihood, Acta Cryst. A52, 659-668 (1996) +} 
 CNSsolve> 
 CNSsolve>{- Guidelines for using this file: 
 CNSsolve>   - all strings must be quoted by double-quotes 
 CNSsolve>   - logical variables (true/false) are not quoted 
 CNSsolve>   - do not remove any evaluate statements from the file -} 
 CNSsolve> 
 CNSsolve>{- begin block parameter definition -} define( 
 DEFINE> 
 DEFINE>{============================ coordinates ============================} 
 DEFINE> 
 DEFINE>{* coordinate file *} 
 DEFINE>{===>} coordinate_infile="mm3.pdb"; 
 DEFINE> 
 DEFINE>{==================== molecular information ==========================} 
 DEFINE> 
 DEFINE>{* topology files *} 
 DEFINE>{===>} topology_infile_1="CNS_TOPPAR:protein.top"; 
 DEFINE>{===>} topology_infile_2="CNS_TOPPAR:dna-rna.top"; 
 DEFINE>{===>} topology_infile_3="CNS_TOPPAR:water.top"; 
 DEFINE>{===>} topology_infile_4="CNS_TOPPAR:ion.top"; 
 DEFINE>{===>} topology_infile_5="CNS_TOPPAR:carbohydrate.top"; 
 DEFINE>{===>} topology_infile_6="CIA.top"; 
 DEFINE>{===>} topology_infile_7=""; 
 DEFINE>{===>} topology_infile_8=""; 
 DEFINE> 
 DEFINE>{* linkage files for linear, continuous polymers (protein, DNA, RNA) *} 
 DEFINE>{===>} link_infile_1="CNS_TOPPAR:protein.link"; 
 DEFINE>{===>} link_infile_2="CNS_TOPPAR:dna-rna-pho.link"; 
 DEFINE>{===>} link_infile_3=""; 
 DEFINE> 
 DEFINE>{* parameter files *} 
 DEFINE>{===>} parameter_infile_1="CNS_TOPPAR:protein_rep.param"; 
 DEFINE>{===>} parameter_infile_2="CNS_TOPPAR:dna-rna_rep.param"; 
 DEFINE>{===>} parameter_infile_3="CNS_TOPPAR:water_rep.param"; 
 DEFINE>{===>} parameter_infile_4="CNS_TOPPAR:ion.param"; 
 DEFINE>{===>} parameter_infile_5="CNS_TOPPAR:carbohydrate.param"; 
 DEFINE>{===>} parameter_infile_6="CIA.par"; 
 DEFINE>{===>} parameter_infile_7=""; 
 DEFINE>{===>} parameter_infile_8=""; 
 DEFINE> 
 DEFINE>{* molecular topology file: optional (leave blank for auto generation) *} 
 DEFINE>{* 
 DEFINE>   Auto generation of the molecular topology from the coordinates should only 
 DEFINE>   be used if: 
 DEFINE>   (1) Each distinct protein, DNA, or RNA chain must have a separate segid 
 DEFINE>       (or chainid if the chainid is non-blank). 
 DEFINE>   (2) Each contiguous protein, RNA, or RNA chain must not be disrupted by 
 DEFINE>       other types of residues or ligands.  Rather, these other residues 
 DEFINE>       should be listed after protein, RNA/DNA chains. 
 DEFINE>   (3) Disulphides are automatically detected based on distances between the sulfur atoms 
 DEFINE>      (must be less than 3 A apart). 
 DEFINE>   (4) Broken protein/RNA/DNA chains without terminii must be more than 2.5 A apart to be recognized as such. 
 DEFINE>   (5) N-linked glycan links are automatically recognized if the bonded atoms are less than 2.5 A apart. 
 DEFINE>   (6) Automatic generation cannot be used with alternate conformations. 
 DEFINE>   For ligands, the user must make suitable topology and parameter files. 
 DEFINE>   For non-standard covalent linkages, the custom patch file should be used. 
 DEFINE>   Alternatively, the generate.inp or generate_easy.inp task files 
 DEFINE>   can be used to generated the mtf prior to running this task file. 
 DEFINE>    *} 
 DEFINE>{===>} structure_infile="mm3.mtf"; 
 DEFINE> 
 DEFINE>{* for auto generation: extra linkages and modifications by custom patches *} 
 DEFINE>{===>} patch_infile=""; 
 DEFINE> 
 DEFINE> 
 DEFINE>{====================== crystallographic data ========================} 
 DEFINE> 
 DEFINE>{* space group *} 
 DEFINE>{* use International Table conventions with subscripts substituted 
 DEFINE>   by parenthesis *} 
 DEFINE>{===>} sg="C2"; 
 DEFINE> 
 DEFINE>{* unit cell parameters in Angstroms and degrees *} 
 DEFINE>{+ table: rows=1 "cell" cols=6 "a" "b" "c" "alpha" "beta" "gamma" +} 
 DEFINE>{===>} a=56.102; 
 DEFINE>{===>} b=76.397; 
 DEFINE>{===>} c=80.699; 
 DEFINE>{===>} alpha=90.00; 
 DEFINE>{===>} beta=103.18; 
 DEFINE>{===>} gamma=90.00; 
 DEFINE> 
 DEFINE>{* anomalous f' f'' library file *} 
 DEFINE>{* If a file is not specified, no anomalous contribution will be included *} 
 DEFINE>{+ choice: "CNS_XRAYLIB:anom_cu.lib" "CNS_XRAYLIB:anom_mo.lib" "" user_file +} 
 DEFINE>{===>} anom_library=""; 
 DEFINE> 
 DEFINE>{* reflection files *} 
 DEFINE>{* specify non-anomalous reflection files before anomalous reflection files. *} 
 DEFINE>{* files must contain unique array names otherwise errors will occur *} 
 DEFINE>{===>} reflection_infile_1="1xoz-sf.cv"; 
 DEFINE>{===>} reflection_infile_2=""; 
 DEFINE>{===>} reflection_infile_3=""; 
 DEFINE>{===>} reflection_infile_4=""; 
 DEFINE> 
 DEFINE>{* reciprocal space array containing observed amplitudes: required *} 
 DEFINE>{===>} obs_f="fobs"; 
 DEFINE> 
 DEFINE>{* reciprocal space array containing sigma values for amplitudes: required *} 
 DEFINE>{===>} obs_sigf="sigma"; 
 DEFINE> 
 DEFINE>{* reciprocal space array containing test set for cross-validation: required *} 
 DEFINE>{* cross-validation should always be used, with the possible exception 
 DEFINE>   of a final round of refinement including all data *} 
 DEFINE>{* cross-validation is always required for the maximum likelihood targets *} 
 DEFINE>{===>} test_set="test"; 
 DEFINE> 
 DEFINE>{* number for selection of test reflections: required for cross-validation *} 
 DEFINE>{* ie. reflections with the test set array equal to this number will be 
 DEFINE>       used for cross-validation, all other reflections form the working set *} 
 DEFINE>{===>} test_flag=1; 
 DEFINE> 
 DEFINE>{* reciprocal space array containing weighting scheme for observed 
 DEFINE>   amplitudes: optional *} 
 DEFINE>{* only used for the "residual" and "vector" targets - this will 
 DEFINE>   default to a constant value of 1 if array is not present *} 
 DEFINE>{===>} obs_w=""; 
 DEFINE> 
 DEFINE>{* reciprocal space array containing observed intensities: optional *} 
 DEFINE>{* required for the "mli" target *} 
 DEFINE>{===>} obs_i=""; 
 DEFINE> 
 DEFINE>{* reciprocal space array containing sigma values for intensities: optional *} 
 DEFINE>{* required for the "mli" target *} 
 DEFINE>{===>} obs_sigi=""; 
 DEFINE> 
 DEFINE>{* reciprocal space arrays with experimental phase probability 
 DEFINE>   distribution: optional *} 
 DEFINE>{* Hendrickson-Lattman coefficients A,B,C,D *} 
 DEFINE>{* required for the "mlhl" target *} 
 DEFINE>{+ table: rows=1 "HL coefficients" cols=4 "A" "B" "C" "D" +} 
 DEFINE>{===>} obs_pa=""; 
 DEFINE>{===>} obs_pb=""; 
 DEFINE>{===>} obs_pc=""; 
 DEFINE>{===>} obs_pd=""; 
 DEFINE> 
 DEFINE>{* complex reciprocal space array containing experimental phases: optional *} 
 DEFINE>{* required for the "mixed" and "vector" targets *} 
 DEFINE>{===>} obs_phase=""; 
 DEFINE> 
 DEFINE>{* reciprocal space array containing experimental figures of merit: optional *} 
 DEFINE>{* required for the "mixed" target *} 
 DEFINE>{===>} obs_fom=""; 
 DEFINE> 
 DEFINE>{* resolution limits to be used in refinement *} 
 DEFINE>{* the full resolution range of observed data should be used in refinement. 
 DEFINE>   A bulk solvent correction should be applied to allow the use of low 
 DEFINE>   resolution terms. If no bulk solvent correction is applied, data must 
 DEFINE>   be truncated at a lower resolution limit of between 8 and 6 Angstrom. *} 
 DEFINE>{+ table: rows=1 "resolution" cols=2 "lowest" "highest" +} 
 DEFINE>{===>} low_res=79.06; 
 DEFINE>{===>} high_res=1.37; 
 DEFINE> 
 DEFINE>{* apply rejection criteria to amplitudes or intensities *} 
 DEFINE>{+ choice: "amplitude" "intensity" +} 
 DEFINE>{===>} obs_type="amplitude"; 
 DEFINE> 
 DEFINE>{* Observed data cutoff criteria: applied to amplitudes or intensities *} 
 DEFINE>{* reflections with magnitude(Obs)/sigma < cutoff are rejected. *} 
 DEFINE>{===>} sigma_cut=0.0; 
 DEFINE> 
 DEFINE>{* rms outlier cutoff: applied to amplitudes or intensities *} 
 DEFINE>{* reflections with magnitude(Obs) > cutoff*rms(Obs) will be rejected *} 
 DEFINE>{===>} obs_rms=10000; 
 DEFINE> 
 DEFINE>{=================== non-crystallographic symmetry ===================} 
 DEFINE> 
 DEFINE>{* NCS-restraints/constraints file *} 
 DEFINE>{* see auxiliary/ncs.def *} 
 DEFINE>{===>} ncs_infile=""; 
 DEFINE> 
 DEFINE>{============ overall B-factor and bulk solvent corrections ==========} 
 DEFINE> 
 DEFINE>{* overall B-factor correction *} 
 DEFINE>{+ choice: "no" "isotropic" "anisotropic" +} 
 DEFINE>{===>} bscale="anisotropic"; 
 DEFINE> 
 DEFINE>{* bulk solvent correction *} 
 DEFINE>{* a mask is required around the molecule(s). The region 
 DEFINE>   outside this mask is the solvent region *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} bulk_sol=true; 
 DEFINE> 
 DEFINE>{* bulk solvent mask file *} 
 DEFINE>{* mask will be read from O type mask file if a name is given 
 DEFINE>   otherwise calculated from coordinates of selected atoms *} 
 DEFINE>{===>} bulk_mask_infile=""; 
 DEFINE> 
 DEFINE>{* automatic bulk solvent parameter optimization for e-density level sol_k (e/A^3) and B-factor sol_b (A^2) *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} sol_auto=true; 
 DEFINE> 
 DEFINE>{* fixed solvent parameters (used if the automatic option is turned off) *} 
 DEFINE>{+ table: rows=1 "bulk solvent" cols=2 "e-density level sol_k (e/A^3)" "B-factor sol_b (A^2) " +} 
 DEFINE>{===>} sol_k=0.3; 
 DEFINE>{===>} sol_b=50.0; 
 DEFINE> 
 DEFINE>{* optional file with a listing of the results of the automatic bulk solvent optimization *} 
 DEFINE>{===>} sol_output=""; 
 DEFINE> 
 DEFINE>{* solvent mask parameters *} 
 DEFINE>{+ table: rows=1 "bulk solvent" cols=2 "probe radius (A) (usually set to 1)" "shrink radius (A) (usually set to 1)" +} 
 DEFINE>{===>} sol_rad=1.0; 
 DEFINE>{===>} sol_shrink=1.0; 
 DEFINE> 
 DEFINE>{========================== atom selection ===========================} 
 DEFINE> 
 DEFINE>{* select atoms to be included *} 
 DEFINE>{===>} atom_select=(known and not hydrogen); 
 DEFINE> 
 DEFINE>{* select atoms whose B-factors will remain fixed *} 
 DEFINE>{===>} atom_fixed=(none); 
 DEFINE> 
 DEFINE>{* select main chain atoms for target sigma assignment *} 
 DEFINE>{* note: atoms outside this selection will be considered to be 
 DEFINE>   side chain atoms *} 
 DEFINE>{===>} atom_main=(name ca or name n or name c or name o or name ot+); 
 DEFINE> 
 DEFINE>{================ B-factor minimization parameters ===================} 
 DEFINE> 
 DEFINE>{* reset all atomic B factors to this number if positive *} 
 DEFINE>{===>} reset_b=-1; 
 DEFINE> 
 DEFINE>{* number of steps of restrained individual B-factor minimization *} 
 DEFINE>{===>} bfactor_nstep=1; 
 DEFINE> 
 DEFINE>{* weight for B-factor restraints *} 
 DEFINE>{* if -1, the weight will be automatically determined. 
 DEFINE>   At later stages of refinement the optimal value for rweight can 
 DEFINE>   be determined using the optimize_rweight.inp script *} 
 DEFINE>{===>} rweight=-1; 
 DEFINE> 
 DEFINE>{* B-factor limits *} 
 DEFINE>{+ table: rows=1 "B-factor" cols=2 "minimum" "maximum" +} 
 DEFINE>{===>} bmin=1; 
 DEFINE>{===>} bmax=900; 
 DEFINE> 
 DEFINE>{* target sigma values for restrained B-factor refinement *} 
 DEFINE> 
 DEFINE>{* mainchain bonds *} 
 DEFINE>{===>} bsig_main=1.5; 
 DEFINE>{* mainchain angles *} 
 DEFINE>{===>} asig_main=2.0; 
 DEFINE> 
 DEFINE>{* sidechain bonds *} 
 DEFINE>{===>} bsig_side=2.0; 
 DEFINE>{* sidechain angles *} 
 DEFINE>{===>} asig_side=2.5; 
 DEFINE> 
 DEFINE>{* refinement target *} 
 DEFINE>{+ list: mlf: maximum likelihood target using amplitudes 
 DEFINE>         mli: maximum likelihood target using intensities 
 DEFINE>        mlhl: maximum likelihood target using amplitudes 
 DEFINE>              and phase probability distribution 
 DEFINE>    residual: standard crystallographic residual 
 DEFINE>      vector: vector residual 
 DEFINE>       mixed: (1-fom)*residual + fom*vector 
 DEFINE>        e2e2: correlation coefficient using normalized E^2 
 DEFINE>        e1e1: correlation coefficient using normalized E 
 DEFINE>        f2f2: correlation coefficient using F^2 
 DEFINE>        f1f1: correlation coefficient using F +} 
 DEFINE>{+ choice: "mlf" "mli" "mlhl" "residual" "vector" "mixed" 
 DEFINE>           "e2e2" "e1e1" "f2f2" "f1f1" +} 
 DEFINE>{===>} reftarget="mlf"; 
 DEFINE> 
 DEFINE>{* number of bins for refinement target *} 
 DEFINE>{* this will be determined automatically if a negative value is given 
 DEFINE>   otherwise the specified number of bins will be used *} 
 DEFINE>{===>} target_bins=-1; 
 DEFINE> 
 DEFINE>{* memory allocation for FFT calculation *} 
 DEFINE>{* this will be determined automatically if a negative value is given 
 DEFINE>   otherwise the specified number of words will be allocated *} 
 DEFINE>{===>} fft_memory=-1; 
 DEFINE> 
 DEFINE>{=========================== output files ============================} 
 DEFINE> 
 DEFINE>{* output coordinate file *} 
 DEFINE>{===>} coordinate_outfile="bindividual.pdb"; 
 DEFINE> 
 DEFINE>{===========================================================================} 
 DEFINE>{         things below this line do not normally need to be changed         } 
 DEFINE>{===========================================================================} 
 DEFINE> 
 DEFINE> ) {- end block parameter definition -} 
 CNSsolve> 
 CNSsolve> checkversion 1.3 
 Program version= 1.3 File version= 1.3
 CNSsolve> 
 CNSsolve> evaluate ($log_level=quiet) 
 Assuming literal string "QUIET"
 EVALUATE: symbol $LOG_LEVEL set to "QUIET" (string)
 CNSsolve> 
 CNSsolve> if ( $log_level = verbose ) then 
 NEXTCD: condition evaluated as false
 CNSsolve>   set message=normal echo=on end 
 CNSsolve> else 
 CNSsolve>   set message=off echo=off end 
 REMARKS FILENAME="mm3.mtf"
 REMARKS DATE:19-Dec-2023  10:22:23       created by user: yanz
 REMARKS VERSION:1.3
 %PARRDR-info: duplication of nonbonded entry C3  
 %PARRDR-info: duplication of nonbonded entry C2  
 %PARRDR-info: duplication of nonbonded entry H2  
 CNSsolve> 
 CNSsolve> xray 
 XRAY> 
 XRAY>   @CNS_XTALLIB:spacegroup.lib (sg=&sg; 
 ASSFIL: file spacegroup.lib opened.
 XRAY>! file  libraries/xtal/spacegroup.lib 
 XRAY>! library of symmetry operators for CNS 
 XRAY>! Automatically generated with SgInfo Version 2.00a13 
 XRAY> 
 XRAY>module 
 MODULE-DECLARATION>( 
 MODULE-DECLARATION>  &sg=$sg; 
 MODULE-DECLARATION>  &sgparam=$sgparam; 
 MODULE-DECLARATION>) 
 &_2_SG set to &_1_SG 
 MODULE-INVOCATION>                                sgparam=$sgparam;) 
 &_2_SGPARAM set to $_1_SGPARAM 
 XRAY> 
 XRAY>set message ? end 
 MESSage=NORM
 XRAY>evaluate ($message_old=$result) 
 EVALUATE: symbol $MESSAGE_OLD set to "NORM" (string)
 XRAY>set echo ? end 
 ECHO=TRUE {ON}
 XRAY>evaluate ($echo_old=$result) 
 EVALUATE: symbol $ECHO_OLD set to TRUE (logical)
 XRAY>set echo=off message=off end 
SYMMETRY: found symmetry operators for space group "C2" in library
 XRAY> 
 XRAY> 
 XRAY>   a=&a b=&b c=&c  alpha=&alpha beta=&beta gamma=&gamma 
 XRAY> 
 XRAY>   @CNS_XRAYLIB:scatter.lib 
 ASSFIL: file scatter.lib opened.
 XRAY>! file libraries/xray/scatter.lib 
 XRAY>! Atomic scattering factors without anomalous contribution 
 XRAY>! Library for CNS 
 XRAY> 
 XRAY>! Authors: Paul Adams, Joe Jaeger, and Axel T. Brunger 
 XRAY> 
 XRAY>!BEWARE: 
 XRAY>!(1) element Cf (Californium) has to be referred to as Cff 
 XRAY>!(2) element Sm (Samarium) has to be referred to as Smm 
 XRAY>!(3) element Np (Neptunium) has to be referred to as Npp 
 XRAY>!(3) types of elements with ionic state (i.e., +/-) specifications have 
 XRAY>!    to be put in double quotes in selection statements. 
 XRAY> 
 XRAY>set message ? end 
 MESSage=NORM
 XRAY>evaluate ($message_old_sclib=$result) 
 EVALUATE: symbol $MESSAGE_OLD_SCLIB set to "NORM" (string)
 XRAY>set echo ? end 
 ECHO=TRUE {ON}
 XRAY>evaluate ($echo_old_sclib=$result) 
 EVALUATE: symbol $ECHO_OLD_SCLIB set to TRUE (logical)
 XRAY>set echo=off message=off end 
 XRAY>   evaluate ($counter=1) 
 EVALUATE: symbol $COUNTER set to    1.00000     (real)
 XRAY>   evaluate ($done=false) 
 EVALUATE: symbol $DONE set to FALSE (logical)
 XRAY>   while ( $done = false ) loop read 
 NEXTCD: condition evaluated as true
 XRAY>    if ( &exist_reflection_infile_$counter = true ) then 
 NEXTCD: condition evaluated as true
 XRAY>      if ( &BLANK%reflection_infile_$counter = false ) then 
 NEXTCD: condition evaluated as true
 XRAY>       reflection 
 REFLection>         @@&reflection_infile_$counter 
 ASSFIL: file 1xoz-sf.cv opened.
 REFLection> remark a= 56.102 b= 76.397 c= 80.699 alpha= 90 beta= 103.18 gamma= 90 sg= C2 
 REFLection> remark symop (X,Y,Z) 
 REFLection> remark symop (-X,Y,-Z) 
 REFLection> remark symop (X+1/2,Y+1/2,Z) 
 REFLection> remark symop (-X+1/2,Y+1/2,-Z) 
 REFLection>CRYST1   56.102   76.397   80.699  90.00 103.18  90.00 C 2 
 REFLection> NREFlection=     75210 
 XRAY: increasing space allocation for up to   75210 reflections.
 REFLection> ANOMalous=FALSe { equiv. to HERMitian=TRUE} 
 REFLection> DECLare NAME=FOBS                   DOMAin=RECIprocal   TYPE=REAL END 
 XDECLARE: Object FOBS has been declared.
 REFLection> DECLare NAME=SIGMA                  DOMAin=RECIprocal   TYPE=REAL END 
 XDECLARE: Object SIGMA has been declared.
 REFLection> DECLare NAME=TEST                   DOMAin=RECIprocal   TYPE=INTE END 
 XDECLARE: Object TEST has been declared.
 REFLection> INDE   -40    0    1 FOBS=    32.500 SIGMA=    18.800 TEST=         0 
 XSFAL: allocating space for real reciprocal space object.
 XSFAL: allocating space for real reciprocal space object.
 XSFAL: allocating space for integer reciprocal space object.
 XRRR2:    75210 new h,k,l indices have been added.
 XRAY>      end if 
 XRAY>   else 
 XRAY>     evaluate ($done=true) 
 XRAY>   end if 
 XRAY>   evaluate ($counter=$counter+1) 
 EVALUATE: symbol $COUNTER set to    2.00000     (real)
 XRAY>  end loop read 
 XRAY>   while ( $done = false ) loop read 
 NEXTCD: condition evaluated as true
 XRAY>    if ( &exist_reflection_infile_$counter = true ) then 
 NEXTCD: condition evaluated as true
 XRAY>      if ( &BLANK%reflection_infile_$counter = false ) then 
 NEXTCD: condition evaluated as false
 XRAY>       reflection 
 XRAY>         @@&reflection_infile_$counter 
 XRAY>       end 
 XRAY>      end if 
 XRAY>   else 
 XRAY>     evaluate ($done=true) 
 XRAY>   end if 
 XRAY>   evaluate ($counter=$counter+1) 
 EVALUATE: symbol $COUNTER set to    3.00000     (real)
 XRAY>  end loop read 
 XRAY>   while ( $done = false ) loop read 
 NEXTCD: condition evaluated as true
 XRAY>    if ( &exist_reflection_infile_$counter = true ) then 
 NEXTCD: condition evaluated as true
 XRAY>      if ( &BLANK%reflection_infile_$counter = false ) then 
 NEXTCD: condition evaluated as false
 XRAY>       reflection 
 XRAY>         @@&reflection_infile_$counter 
 XRAY>       end 
 XRAY>      end if 
 XRAY>   else 
 XRAY>     evaluate ($done=true) 
 XRAY>   end if 
 XRAY>   evaluate ($counter=$counter+1) 
 EVALUATE: symbol $COUNTER set to    4.00000     (real)
 XRAY>  end loop read 
 XRAY>   while ( $done = false ) loop read 
 NEXTCD: condition evaluated as true
 XRAY>    if ( &exist_reflection_infile_$counter = true ) then 
 NEXTCD: condition evaluated as true
 XRAY>      if ( &BLANK%reflection_infile_$counter = false ) then 
 NEXTCD: condition evaluated as false
 XRAY>       reflection 
 XRAY>         @@&reflection_infile_$counter 
 XRAY>       end 
 XRAY>      end if 
 XRAY>   else 
 XRAY>     evaluate ($done=true) 
 XRAY>   end if 
 XRAY>   evaluate ($counter=$counter+1) 
 EVALUATE: symbol $COUNTER set to    5.00000     (real)
 XRAY>  end loop read 
 XRAY>   while ( $done = false ) loop read 
 NEXTCD: condition evaluated as true
 XRAY>    if ( &exist_reflection_infile_$counter = true ) then 
 NEXTCD: condition evaluated as false
 XRAY>      if ( &BLANK%reflection_infile_$counter = false ) then 
 XRAY>       reflection 
 XRAY>         @@&reflection_infile_$counter 
 XRAY>       end 
 XRAY>      end if 
 XRAY>   else 
 XRAY>     evaluate ($done=true) 
 EVALUATE: symbol $DONE set to TRUE (logical)
 XRAY>   end if 
 XRAY>   evaluate ($counter=$counter+1) 
 EVALUATE: symbol $COUNTER set to    6.00000     (real)
 XRAY>  end loop read 
 XRAY>   while ( $done = false ) loop read 
 NEXTCD: condition evaluated as false
 XRAY>    if ( &exist_reflection_infile_$counter = true ) then 
 XRAY>      if ( &BLANK%reflection_infile_$counter = false ) then 
 XRAY>       reflection 
 XRAY>         @@&reflection_infile_$counter 
 XRAY>       end 
 XRAY>      end if 
 XRAY>   else 
 XRAY>     evaluate ($done=true) 
 XRAY>   end if 
 XRAY>   evaluate ($counter=$counter+1) 
 XRAY>  end loop read 
 XRAY> 
 XRAY> end 
 CNSsolve> 
 CNSsolve> if ( &BLANK%anom_library = false ) then 
 NEXTCD: condition evaluated as false
 CNSsolve>   @@&anom_library 
 CNSsolve> else 
 CNSsolve>   set echo=off end 
 ANOMalous=FALSe {OFF}
 NEXTCD: condition evaluated as false
 CNSsolve> end if 
 CNSsolve> 
 CNSsolve> {- copy define parameters of optional arrays into symbols so 
 CNSsolve>    we can redefine them -} 
 CNSsolve> 
 CNSsolve> evaluate ($obs_i=&obs_i) 
 EVALUATE: symbol $OBS_I set to "" (string)
 CNSsolve> evaluate ($obs_sigi=&obs_sigi) 
 EVALUATE: symbol $OBS_SIGI set to "" (string)
 CNSsolve> evaluate ($obs_w=&obs_w) 
 EVALUATE: symbol $OBS_W set to "" (string)
 CNSsolve> xray 
 XRAY>   @@CNS_XTALMODULE:checkrefinput ( 
 ASSFIL: file checkrefinput opened.
 XRAY>! Module file: checkrefinput 
 XRAY>! 
 XRAY>! CNS module 
 XRAY>! ********** 
 XRAY>! 
 XRAY>! Authors: Axel Brunger and Paul Adams 
 XRAY>! 
 XRAY>! copyright Yale University 
 XRAY>! 
 XRAY>! Function: 
 XRAY>!    Checks the required input reciprocal space arrays 
 XRAY>! 
 XRAY>! Requirements: 
 XRAY>!    Needs to be called within xray 
 XRAY> 
 XRAY>module {checkrefinput} 
 MODULE-DECLARATION> 
 MODULE-DECLARATION>( 
 MODULE-DECLARATION>  &reftarget="residual"; {string} 
 MODULE-DECLARATION>  &obs_f;                {reciprocal space array} 
 MODULE-DECLARATION>  &obs_sigf;             {reciprocal space array} 
 MODULE-DECLARATION>  &test_set;             {reciprocal space array} 
 MODULE-DECLARATION>  &obs_pa;               {reciprocal space array} 
 MODULE-DECLARATION>  &obs_pb;               {reciprocal space array} 
 MODULE-DECLARATION>  &obs_pc;               {reciprocal space array} 
 MODULE-DECLARATION>  &obs_pd;               {reciprocal space array} 
 MODULE-DECLARATION>  &obs_phase;            {reciprocal space array} 
 MODULE-DECLARATION>  &obs_fom;              {reciprocal space array} 
 MODULE-DECLARATION>  &obs_w;                {reciprocal space array} 
 MODULE-DECLARATION>  &obs_i;                {reciprocal space array} 
 MODULE-DECLARATION>  &obs_sigi;             {reciprocal space array} 
 MODULE-DECLARATION>) 
 MODULE-INVOCATION>                                  reftarget=&reftarget; 
 &_2_REFTARGET set to &_1_REFTARGET 
 MODULE-INVOCATION>                                  obs_f=&obs_f; 
 &_2_OBS_F set to &_1_OBS_F 
 MODULE-INVOCATION>                                  obs_sigf=&obs_sigf; 
 &_2_OBS_SIGF set to &_1_OBS_SIGF 
 MODULE-INVOCATION>                                  test_set=&test_set; 
 &_2_TEST_SET set to &_1_TEST_SET 
 MODULE-INVOCATION>                                  obs_pa=&obs_pa; 
 &_2_OBS_PA set to &_1_OBS_PA 
 MODULE-INVOCATION>                                  obs_pb=&obs_pb; 
 &_2_OBS_PB set to &_1_OBS_PB 
 MODULE-INVOCATION>                                  obs_pc=&obs_pc; 
 &_2_OBS_PC set to &_1_OBS_PC 
 MODULE-INVOCATION>                                  obs_pd=&obs_pd; 
 &_2_OBS_PD set to &_1_OBS_PD 
 MODULE-INVOCATION>                                  obs_phase=&obs_phase; 
 &_2_OBS_PHASE set to &_1_OBS_PHASE 
 MODULE-INVOCATION>                                  obs_fom=&obs_fom; 
 &_2_OBS_FOM set to &_1_OBS_FOM 
 MODULE-INVOCATION>                                  obs_w=$obs_w; 
 &_2_OBS_W set to $_1_OBS_W 
 MODULE-INVOCATION>                                  obs_i=$obs_i; 
 &_2_OBS_I set to $_1_OBS_I 
 MODULE-INVOCATION>                                  obs_sigi=$obs_sigi; 
 &_2_OBS_SIGI set to $_1_OBS_SIGI 
 MODULE-INVOCATION>                                  ) 
 XRAY> 
 XRAY>set message ? end 
 MESSage=NORM
 XRAY>evaluate ($message_old_cri=$result) 
 EVALUATE: symbol $MESSAGE_OLD_CRI set to "NORM" (string)
 XRAY>set echo ? end 
 ECHO=TRUE {ON}
 XRAY>evaluate ($echo_old_cri=$result) 
 EVALUATE: symbol $ECHO_OLD_CRI set to TRUE (logical)
 XRAY>if ( $log_level = verbose ) then 
 NEXTCD: condition evaluated as false
 XRAY>  set echo=on message=normal end 
 XRAY>else 
 XRAY>  set echo=off message=off end 
 XRAY> 
 XRAY>   query name=fcalc domain=reciprocal end 
 Reciprocal space object FCALC does not exist.
 XRAY>   if ( $object_exist = false ) then 
 NEXTCD: condition evaluated as true
 XRAY>      declare name=fcalc domain=reciprocal type=complex end 
 XDECLARE: Object FCALC has been declared.
 XRAY>   end if 
 XRAY>   declare name=fbulk domain=reciprocal type=complex end 
 XDECLARE: Object FBULK has been declared.
 XRAY>   do (fbulk=0) ( all ) 
 XSFAL: allocating space for complex reciprocal space object.
 Total of     75210 structure factor elements were selected.
 XRAY> 
 XRAY>   binresolution &low_res &high_res 
 XRAY>   mapresolution &high_res 
 XRAY> 
 XRAY>   if ( &obs_type = "intensity" ) then 
 NEXTCD: condition evaluated as false
 XRAY>     if ( &BLANK%obs_i = true ) then 
 XRAY>       display  Error: observed intensity array is undefined 
 XRAY>       display         aborting script 
 XRAY>       abort 
 XRAY>     end if 
 XRAY>     evaluate ($reject_obs=&obs_i) 
 XRAY>     evaluate ($reject_sig=&obs_sigi) 
 XRAY>   else 
 XRAY>     evaluate ($reject_obs=&obs_f) 
 EVALUATE: symbol $REJECT_OBS set to "fobs" (string)
 XRAY>     evaluate ($reject_sig=&obs_sigf) 
 EVALUATE: symbol $REJECT_SIG set to "sigma" (string)
 XRAY>   end if 
 XRAY> 
 XRAY>   declare name=ref_active domain=reciprocal type=integer end 
 XDECLARE: Object REF_ACTIVE has been declared.
 XRAY>   declare name=tst_active domain=reciprocal type=integer end 
 XDECLARE: Object TST_ACTIVE has been declared.
 XRAY> 
 XRAY>   do (ref_active=0) ( all ) 
 XSFAL: allocating space for integer reciprocal space object.
 Total of     75210 structure factor elements were selected.
 XRAY>   do (ref_active=1) ( ( $STRIP%reject_sig # 0 ) and 
 DO>                      ( &low_res >= d >= &high_res ) ) 
 Total of     67682 structure factor elements were selected.
 XRAY> 
 XRAY>   statistics overall 
 STATistics>     completeness 
 STATistics>     selection=( ref_active=1 ) 
 Total of     67682 structure factor elements were selected.
 STATistics>   end 
 XRAY>   evaluate ($total_compl=$expression1) 
 EVALUATE: symbol $TOTAL_COMPL set to   0.973842     (real)
 XRAY> 
 XRAY>   show sum(1) ( ref_active=1 ) 
 Sum of     67682 elements =             67682.0000
 XRAY>   evaluate ($total_read=$select) 
 EVALUATE: symbol $TOTAL_READ set to    67682.0     (real)
 XRAY>   evaluate ($total_theor=int(1./$total_compl * $total_read)) 
 EVALUATE: symbol $TOTAL_THEOR set to    69500.0     (real)
 XRAY> 
 XRAY>   show rms (amplitude($STRIP%reject_obs)) ( ref_active=1 ) 
 Rms of     67682 elements =               121.8191
 XRAY>   evaluate ($obs_high=$result*&obs_rms) 
 EVALUATE: symbol $OBS_HIGH set to   0.121819E+07 (real)
 XRAY>   show min (amplitude($STRIP%reject_obs)) ( ref_active=1 ) 
 Minimum of     67682 elements =                 6.7000
 XRAY>   evaluate ($obs_low=$result) 
 EVALUATE: symbol $OBS_LOW set to    6.70000     (real)
 XRAY> 
 XRAY>   do (ref_active=0) ( all ) 
 Total of     75210 structure factor elements were selected.
 XRAY>   do (ref_active=1) 
 DO>                  ( ( amplitude($STRIP%reject_obs) > &sigma_cut*$STRIP%reject_sig ) and 
 DO>                    ( $STRIP%reject_sig # 0 ) and 
 DO>                    ( $obs_low <= amplitude($STRIP%reject_obs) <= $obs_high ) and 
 DO>                    ( &low_res >= d >= &high_res ) ) 
 Total of     67682 structure factor elements were selected.
 XRAY> 
 XRAY>   do (tst_active=0) (all) 
 XSFAL: allocating space for integer reciprocal space object.
 Total of     75210 structure factor elements were selected.
 XRAY>   if ( &BLANK%test_set = false ) then 
 NEXTCD: condition evaluated as true
 XRAY>     do (tst_active=1) (ref_active=1 and &STRIP%test_set=&test_flag) 
 Total of      3442 structure factor elements were selected.
 XRAY>   end if 
 XRAY> 
 XRAY>   show sum(1) ( ref_active=1 and tst_active=0 ) 
 Sum of     64240 elements =             64240.0000
 XRAY>   evaluate ($total_work=$select) 
 EVALUATE: symbol $TOTAL_WORK set to    64240.0     (real)
 XRAY>   show sum(1) ( ref_active=1 and tst_active=1 ) 
 Sum of      3442 elements =              3442.0000
 XRAY>   evaluate ($total_test=$select) 
 EVALUATE: symbol $TOTAL_TEST set to    3442.00     (real)
 XRAY>   evaluate ($total_used=$total_work+$total_test) 
 EVALUATE: symbol $TOTAL_USED set to    67682.0     (real)
 XRAY> 
 XRAY>   evaluate ($unobserved=$total_theor-$total_read) 
 EVALUATE: symbol $UNOBSERVED set to    1818.00     (real)
 XRAY>   evaluate ($rejected=$total_read-$total_used) 
 EVALUATE: symbol $REJECTED set to    0.00000     (real)
 XRAY>   evaluate ($per_unobs=100*($unobserved/$total_theor)) 
 EVALUATE: symbol $PER_UNOBS set to    2.61583     (real)
 XRAY>   evaluate ($per_reject=100*($rejected/$total_theor)) 
 EVALUATE: symbol $PER_REJECT set to    0.00000     (real)
 XRAY>   evaluate ($per_used=100*($total_used/$total_theor)) 
 EVALUATE: symbol $PER_USED set to    97.3842     (real)
 XRAY>   evaluate ($per_work=100*($total_work/$total_theor)) 
 EVALUATE: symbol $PER_WORK set to    92.4317     (real)
 XRAY>   evaluate ($per_test=100*($total_test/$total_theor)) 
 EVALUATE: symbol $PER_TEST set to    4.95252     (real)
 XRAY> 
 XRAY>   associate fcalc ( &atom_select ) 
 SELRPN:   3020 atoms have been selected out of   3020
 XRAY> 
 XRAY>   tselection=( ref_active=1 ) 
 XRAY> 
 XRAY>   cvselection=( tst_active=1 ) 
 XRAY> 
 XRAY>   method=FFT 
 XRAY> 
 XRAY> {- MODIFIED 2/15/06 -} 
 XRAY> end 
 CNSsolve> 
 CNSsolve> 
 CNSsolve> show min ( b ) ( &atom_select ) 
 SELRPN:   3020 atoms have been selected out of   3020
 SHOW: minimum of selected elements =       6.000000
 CNSsolve> evaluate ($b_min=$result) 
 EVALUATE: symbol $B_MIN set to    6.00000     (real)
 CNSsolve> @@CNS_XTALMODULE:fft_parameter_check ( 
 ASSFIL: file fft_parameter_check opened.
 CNSsolve>! Module file: fft_parameter_check 
 CNSsolve>! 
 CNSsolve>! Function: determines the optimum setting for the B-factor inflation 
 CNSsolve>! given the high resolution limit, the gridding factor, and the minimum 
 CNSsolve>! B-factor of the model.   It also determines the recommended ELIM parameter 
 CNSsolve>! as a function of the high resolution limit. 
 CNSsolve>! 
 CNSsolve>! Reference: 
 CNSsolve>! 
 CNSsolve>! Gerard Bricogne (2001), 
 CNSsolve>!   International Tables for Crystallography, Volume B, 2001, p. 87 
 CNSsolve>! 
 CNSsolve>! CNS module 
 CNSsolve>! ********** 
 CNSsolve>! 
 CNSsolve>! Authors: Axel T. Brunger and Paul D. Adams 
 CNSsolve>! 
 CNSsolve>! copyright Yale University 
 CNSsolve>! 
 CNSsolve>! Requirements: 
 CNSsolve>! This module can only be used from the main level of CNS. 
 CNSsolve>! 
 CNSsolve>! 08/03/06 ATB 
 CNSsolve> 
 CNSsolve>module {fft_parameter_check} 
 MODULE-DECLARATION>( 
 MODULE-DECLARATION> &b_min=0;              {input: minimum B-factor of model} 
 MODULE-DECLARATION> &d_min=1.0;            {input: high resolution limit} 
 MODULE-DECLARATION> &q_factor=100;         {input: quality factor - 100 for 1% accuracy} 
 MODULE-DECLARATION> &grid=auto;            {input: if "auto" gridding factor is set automatically} 
 MODULE-DECLARATION>                        {       otherwise gridding factor set to <number>  } 
 MODULE-DECLARATION> &fft_memory=-1;        {input: fft memory; if "-1" use automatic mode } 
 MODULE-DECLARATION> 
 MODULE-DECLARATION> &fft_grid=$fft_grid;   {output: fft gridding factor} 
 MODULE-DECLARATION> &fft_b_add=$fft_b_add; {output: fft B addition} 
 MODULE-DECLARATION> &fft_elim=$fft_elim;   {output: fft elimit factor} 
 MODULE-DECLARATION> 
 MODULE-DECLARATION>) 
 MODULE-INVOCATION>                             d_min=&high_res; 
 &_2_D_MIN set to &_1_HIGH_RES 
 MODULE-INVOCATION>                             b_min=$b_min; 
 &_2_B_MIN set to $_1_B_MIN 
 MODULE-INVOCATION>                             grid=auto; 
 &_2_GRID set to auto 
 MODULE-INVOCATION>                             fft_memory=&fft_memory; 
 &_2_FFT_MEMORY set to &_1_FFT_MEMORY 
 MODULE-INVOCATION>                             fft_grid=$fft_grid; 
 &_2_FFT_GRID set to $_1_FFT_GRID 
 MODULE-INVOCATION>                             fft_b_add=$fft_b_add; 
 &_2_FFT_B_ADD set to $_1_FFT_B_ADD 
 MODULE-INVOCATION>                             fft_elim=$fft_elim; 
 &_2_FFT_ELIM set to $_1_FFT_ELIM 
 MODULE-INVOCATION>                                      ) 
 CNSsolve> 
 CNSsolve> set message ? end 
 MESSage=NORM
 CNSsolve> evaluate ($message_old=$result) 
 EVALUATE: symbol $MESSAGE_OLD set to "NORM" (string)
 CNSsolve> set echo ? end 
 ECHO=TRUE {ON}
 CNSsolve> evaluate ($echo_old=$result) 
 EVALUATE: symbol $ECHO_OLD set to TRUE (logical)
 CNSsolve> if ( $log_level = verbose ) then 
 NEXTCD: condition evaluated as false
 CNSsolve>   set echo=on message=normal end 
 CNSsolve> else 
 CNSsolve>   set echo=off message=off end 
 fft_parameter_check: using automatic memory option
 fft_parameter_check: minimum model B-factor = 6  A^2
 fft_parameter_check: high resolution limit = 1.37  A
 fft_parameter_check: fft gridding factor set to 0.3333
 fft_parameter_check: fft B factor offset set to 0  A^2
 fft_parameter_check: fft Elimit factor set to 10
 CNSsolve> 
 CNSsolve> 
 CNSsolve> xray 
 XRAY> {- END MODIFICATION -} 
 XRAY> 
 XRAY>   tolerance=0.0 lookup=false 
 XRAY> 
 XRAY> end 
 CNSsolve> 
 CNSsolve> fix selection=(not(&atom_select) or &atom_fixed) end 
 SELRPN:      0 atoms have been selected out of   3020
 CNSsolve> 
 CNSsolve> igroup interaction (&atom_select) (&atom_select) end 
 SELRPN:   3020 atoms have been selected out of   3020
 SELRPN:   3020 atoms have been selected out of   3020
 CNSsolve> 
 CNSsolve> flags exclude * include xref end 
 CNSsolve> 
 CNSsolve> if ( &BLANK%ncs_infile = false ) then 
 NEXTCD: condition evaluated as false
 CNSsolve>    inline @&ncs_infile 
 CNSsolve> end if 
 CNSsolve> 
 CNSsolve> if ( &reset_b > 0 ) then 
 NEXTCD: condition evaluated as false
 CNSsolve>    do (b=&reset_b) (&atom_select) 
 CNSsolve> end if 
 CNSsolve> 
 CNSsolve> xray 
 XRAY>   predict 
 PREDict>     mode=reciprocal 
 PREDict>     to=fcalc 
 PREDict>     selection=(ref_active=1) 
 Total of     67682 structure factor elements were selected.
 PREDict>     atomselection=( &atom_select ) 
 SELRPN:   3020 atoms have been selected out of   3020
 PREDict>   end 
 FCALC: #scatt.=   3020 #anomalous=   0 #special pos.=  0 occupancies=1
 XSFAL: allocating space for complex reciprocal space object.
 %XFFT-AUTOmem: increasing memory allocation to    2000000
 XFFT: using grid [ 125, 180, 180] and sublattice [ 125( 125), 180( 181),  60]
 XRAY> end 
 CNSsolve> 
 CNSsolve> {- BEGIN MODIFICATION -} 
 CNSsolve> @CNS_XTALMODULE:scale_and_solvent_grid_search ( 
 ASSFIL: file scale_and_solvent_grid_search opened.
 CNSsolve>! Module file: scale_and_solvent_grid_search 
 CNSsolve>! 
 CNSsolve>! Function: determines best bulk solvent model by a grid search in ( k_sol ) space. 
 CNSsolve>!           For each pair of values, the optimum B_sol is determined by least-squares minimization. 
 CNSsolve>!           The module also computes an overall (an)-isotropic B-tensor and applies the isotropic component to the 
 CNSsolve>!           model structure factors, and bulk solvent structure factors; the negated modified 
 CNSsolve>!           B-tensor (-Ucif, with the isotropic component removed) is then applied to the 
 CNSsolve>!           observed amplitudes, sigmas, intensities, and their sigmas.  The corresponding Ucart is 
 CNSsolve>!           passed back to the calling script file. 
 CNSsolve>! 
 CNSsolve>! 
 CNSsolve>! CNS module 
 CNSsolve>! ********** 
 CNSsolve>! 
 CNSsolve>! Authors: Axel T. Brunger and Paul D. Adams 
 CNSsolve>! 
 CNSsolve>! copyright Yale University 
 CNSsolve>! 
 CNSsolve>! Requirements: 
 CNSsolve>! This module can only be used from the main level of CNS. 
 CNSsolve>! 
 CNSsolve>! 6/28/2006 
 CNSsolve> 
 CNSsolve>module {scale_and_solvent_grid_search} 
 MODULE-DECLARATION>( 
 MODULE-DECLARATION> &bscale="no";         {input: "no" | "isotropic" | "anisotropic" } 
 MODULE-DECLARATION> 
 MODULE-DECLARATION> &sel=all;             {input: all active structure factors} 
 MODULE-DECLARATION> &sel_test=none;       {input: test set reflections} 
 MODULE-DECLARATION> &atom_select=( all ); {input: atom selection for all atoms that contribute to calculated structure factor} 
 MODULE-DECLARATION> 
 MODULE-DECLARATION> &bulk_sol=false;      {input: logical flag (true/false) specifying if bulk solvent correction should be computed} 
 MODULE-DECLARATION> &bulk_mask="";        {optional input: mask file for bulk solvent model - it not specified mask will be generated from selected atoms} 
 MODULE-DECLARATION> &bulk_atoms=( all );  {input: atoms used to create solvent mask} 
 MODULE-DECLARATION> 
 MODULE-DECLARATION> &sol_auto=true;       {input: logical flag (true/false) specifying if grid search shall be performed } 
 MODULE-DECLARATION> &sol_k=0.3;           {for sol_auto=false: solvent density fixed at specified value} 
 MODULE-DECLARATION> &sol_b=50.;           {for sol_auto=false: solvent B factor fixed at specified value} 
 MODULE-DECLARATION> &sol_rad=1.0;         {solvent radius (fixed at specified value)} 
 MODULE-DECLARATION> &sol_shrink=1.0;      {shrink factor (fixed at specified value)} 
 MODULE-DECLARATION> 
 MODULE-DECLARATION> &sol_k_range=0.1 0.2 0.25 0.28 0.30 0.32 0.33 0.34 0.35 0.36 0.37 0.38 0.4 0.42 0.45 0.5 0.6; {for sol_auto=true: parameters for sol_k grid search} 
 MODULE-DECLARATION> 
 MODULE-DECLARATION> &fcalc="";            {input/output: calculated structure factors - modified at output (isotropic portion of B-tensor applied)} 
 MODULE-DECLARATION> 
 MODULE-DECLARATION> &obs_f="";            {input/output: observed structure factors - modified at output (negative of anisotropic B-tensor (w/o isotropic portion) applied)} 
 MODULE-DECLARATION> 
 MODULE-DECLARATION> &obs_sigf="";         {input/putput: corresponding sigma array - modified at output (negative of anisotropic B-tensor (w/o isotropic portion) applied)} 
 MODULE-DECLARATION> 
 MODULE-DECLARATION> &obs_i="";            {input/output: observed intensity data - modified at output (negative of anisotropic B-tensor (w/o isotropic portion) applied)} 
 MODULE-DECLARATION> 
 MODULE-DECLARATION> &obs_sigi="";         {input/output: corresponding sigma array - modified at output (negative of anisotropic B-tensor (w/o isotropic portion) applied)} 
 MODULE-DECLARATION> 
 MODULE-DECLARATION> &fpart="";            {output: bulk solvent structure factors (isotropic portion of B-tensor applied)} 
 MODULE-DECLARATION> 
 MODULE-DECLARATION> &Baniso_11;           {required output: anisotropic B-tensor (Ucart) of atomic model, with isotropic component removed } 
 MODULE-DECLARATION> &Baniso_22; 
 MODULE-DECLARATION> &Baniso_33; 
 MODULE-DECLARATION> &Baniso_12; 
 MODULE-DECLARATION> &Baniso_13; 
 MODULE-DECLARATION> &Baniso_23; 
 MODULE-DECLARATION> &Biso;                {required output: isotropic component of the B-tensor } 
 MODULE-DECLARATION> 
 MODULE-DECLARATION> &sol_k_best;          {required output: k_sol of best solvent model} 
 MODULE-DECLARATION> &sol_b_best;          {required output: b_sol of best solvent model} 
 MODULE-DECLARATION> &solrad_best;         {required output: solrad of solvent model that was actually used (for compatibility with previous versions of this module)} 
 MODULE-DECLARATION> &shrink_best;         {required output: shrink value of solvent model that was actually used (for compatibility with previous versions of this module)} 
 MODULE-DECLARATION> 
 MODULE-DECLARATION> &b=b;                 {input/output: atomic B-factor array - isotropic portion of B-factor tensor added } 
 MODULE-DECLARATION> 
 MODULE-DECLARATION> &low_b_flag;          {required output: if true then there were some negative B-factors that have been set to zero } 
 MODULE-DECLARATION> 
 MODULE-DECLARATION> &sol_output="";       {optional output: listing filename for grid search} 
 MODULE-DECLARATION> 
 MODULE-DECLARATION>) 
 MODULE-INVOCATION>                             bscale=&bscale; 
 &_2_BSCALE set to &_1_BSCALE 
 MODULE-INVOCATION>                             sel=( ref_active=1 ); 
 &_2_SEL set to ( ref_active = 1 ) 
 MODULE-INVOCATION>                             sel_test=( tst_active=1 ); 
 &_2_SEL_TEST set to ( tst_active = 1 ) 
 MODULE-INVOCATION>                             atom_select=( &atom_select ); 
 &_2_ATOM_SELECT set to ( &_1_ATOM_SELECT ) 
 MODULE-INVOCATION>                             bulk_sol=&bulk_sol; 
 &_2_BULK_SOL set to &_1_BULK_SOL 
 MODULE-INVOCATION>                             bulk_mask=&bulk_mask_infile; 
 &_2_BULK_MASK set to &_1_BULK_MASK_INFILE 
 MODULE-INVOCATION>                             bulk_atoms=( &atom_select ); 
 &_2_BULK_ATOMS set to ( &_1_ATOM_SELECT ) 
 MODULE-INVOCATION> 
 MODULE-INVOCATION>                             sol_auto=&sol_auto; 
 &_2_SOL_AUTO set to &_1_SOL_AUTO 
 MODULE-INVOCATION>                             sol_k=&sol_k; 
 &_2_SOL_K set to &_1_SOL_K 
 MODULE-INVOCATION>                             sol_b=&sol_b; 
 &_2_SOL_B set to &_1_SOL_B 
 MODULE-INVOCATION>                             sol_rad=&sol_rad; 
 &_2_SOL_RAD set to &_1_SOL_RAD 
 MODULE-INVOCATION>                             sol_shrink=&sol_shrink; 
 &_2_SOL_SHRINK set to &_1_SOL_SHRINK 
 MODULE-INVOCATION> 
 MODULE-INVOCATION>                             fcalc=fcalc; 
 &_2_FCALC set to fcalc 
 MODULE-INVOCATION>                             obs_f=&STRIP%obs_f; 
 &_2_OBS_F set to &STRIP%_1_OBS_F 
 MODULE-INVOCATION>                             obs_sigf=&STRIP%obs_sigf; 
 &_2_OBS_SIGF set to &STRIP%_1_OBS_SIGF 
 MODULE-INVOCATION>                             obs_i=$STRIP%obs_i; 
 &_2_OBS_I set to $STRIP%_1_OBS_I 
 MODULE-INVOCATION>                             obs_sigi=$STRIP%obs_sigi; 
 &_2_OBS_SIGI set to $STRIP%_1_OBS_SIGI 
 MODULE-INVOCATION>                             fpart=fbulk; 
 &_2_FPART set to fbulk 
 MODULE-INVOCATION> 
 MODULE-INVOCATION>! 
 MODULE-INVOCATION>! Begin modification (6/28/06) 
 MODULE-INVOCATION>                             Baniso_11=$Baniso_11; 
 &_2_BANISO_11 set to $_1_BANISO_11 
 MODULE-INVOCATION>                             Baniso_22=$Baniso_22; 
 &_2_BANISO_22 set to $_1_BANISO_22 
 MODULE-INVOCATION>                             Baniso_33=$Baniso_33; 
 &_2_BANISO_33 set to $_1_BANISO_33 
 MODULE-INVOCATION>                             Baniso_12=$Baniso_12; 
 &_2_BANISO_12 set to $_1_BANISO_12 
 MODULE-INVOCATION>                             Baniso_13=$Baniso_13; 
 &_2_BANISO_13 set to $_1_BANISO_13 
 MODULE-INVOCATION>                             Baniso_23=$Baniso_23; 
 &_2_BANISO_23 set to $_1_BANISO_23 
 MODULE-INVOCATION>                             Biso=$Biso_model; 
 &_2_BISO set to $_1_BISO_MODEL 
 MODULE-INVOCATION>! End modification 
 MODULE-INVOCATION>! 
 MODULE-INVOCATION> 
 MODULE-INVOCATION>                             sol_k_best=$sol_k_ref; 
 &_2_SOL_K_BEST set to $_1_SOL_K_REF 
 MODULE-INVOCATION>                             sol_b_best=$sol_b_ref; 
 &_2_SOL_B_BEST set to $_1_SOL_B_REF 
 MODULE-INVOCATION>			     solrad_best=$solrad_best; 
 &_2_SOLRAD_BEST set to $_1_SOLRAD_BEST 
 MODULE-INVOCATION>			     shrink_best=$shrink_best; 
 &_2_SHRINK_BEST set to $_1_SHRINK_BEST 
 MODULE-INVOCATION> 
 MODULE-INVOCATION>                             b=b; 
 &_2_B set to b 
 MODULE-INVOCATION> 
 MODULE-INVOCATION>                             low_b_flag=$low_b_flag; 
 &_2_LOW_B_FLAG set to $_1_LOW_B_FLAG 
 MODULE-INVOCATION> 
 MODULE-INVOCATION>                             sol_output=&sol_output; 
 &_2_SOL_OUTPUT set to &_1_SOL_OUTPUT 
 MODULE-INVOCATION> 
 MODULE-INVOCATION>                             ) 
 CNSsolve> 
 CNSsolve> set message ? end 
 MESSage=NORM
 CNSsolve> evaluate ($message_old2=$result) 
 EVALUATE: symbol $MESSAGE_OLD2 set to "NORM" (string)
 CNSsolve> set echo ? end 
 ECHO=TRUE {ON}
 CNSsolve> evaluate ($echo_old2=$result) 
 EVALUATE: symbol $ECHO_OLD2 set to TRUE (logical)
 CNSsolve> if ( $log_level = verbose ) then 
 NEXTCD: condition evaluated as false
 CNSsolve>   set echo=on message=normal end 
 CNSsolve> else 
 CNSsolve>   set echo=off message=off end 

 trying solvent model with fixed k_sol = 0.1 , solrad = 1.0, shrink = 1.0, bscale option = "anisotropic"
 adjusted grid parameter for solvent mask calculation.  It is now  : 0.416058
 XMASK:     3020 atoms have been selected for mask calculation.
 Minimum brick that covers asymmetric unit:
   A=     0,...,    50  B=     0,...,    72  C=     0,...,   144
 XMASK: average mask radius around selected atoms  1.6648 A
 XMASK: probe radius=  1.0000 shrink radius=  1.0000
 XMASK: volume inside mask=   64.2052% (MASK<=0)
 XMASK: volume outside mask=   35.7948% (MASK=1)
 XRMAPR: symmetry or unitcell changed. Real space obj. deleted.
 refined solvent parameters: sol_k = 0.1  sol_b = -5.44771
>>>> Overall R-value for test set: 0.243621
>>>> Overall R-value for working set: 0.233183

 trying solvent model with fixed k_sol = 0.2 , solrad = 1.0, shrink = 1.0, bscale option = "anisotropic"
 refined solvent parameters: sol_k = 0.2  sol_b = 8.48495
>>>> Overall R-value for test set: 0.22796
>>>> Overall R-value for working set: 0.217782

 trying solvent model with fixed k_sol = 0.25 , solrad = 1.0, shrink = 1.0, bscale option = "anisotropic"
 refined solvent parameters: sol_k = 0.25  sol_b = 16.205
>>>> Overall R-value for test set: 0.222377
>>>> Overall R-value for working set: 0.212302

 trying solvent model with fixed k_sol = 0.28 , solrad = 1.0, shrink = 1.0, bscale option = "anisotropic"
 refined solvent parameters: sol_k = 0.28  sol_b = 21.381
>>>> Overall R-value for test set: 0.219673
>>>> Overall R-value for working set: 0.209716

 trying solvent model with fixed k_sol = 0.3 , solrad = 1.0, shrink = 1.0, bscale option = "anisotropic"
 refined solvent parameters: sol_k = 0.3  sol_b = 25.2845
>>>> Overall R-value for test set: 0.218071
>>>> Overall R-value for working set: 0.208285

 trying solvent model with fixed k_sol = 0.32 , solrad = 1.0, shrink = 1.0, bscale option = "anisotropic"
 refined solvent parameters: sol_k = 0.32  sol_b = 29.1833
>>>> Overall R-value for test set: 0.216709
>>>> Overall R-value for working set: 0.20709

 trying solvent model with fixed k_sol = 0.33 , solrad = 1.0, shrink = 1.0, bscale option = "anisotropic"
 refined solvent parameters: sol_k = 0.33  sol_b = 30.1586
>>>> Overall R-value for test set: 0.21609
>>>> Overall R-value for working set: 0.206548

 trying solvent model with fixed k_sol = 0.34 , solrad = 1.0, shrink = 1.0, bscale option = "anisotropic"
 refined solvent parameters: sol_k = 0.34  sol_b = 32.3872
>>>> Overall R-value for test set: 0.215594
>>>> Overall R-value for working set: 0.206034

 trying solvent model with fixed k_sol = 0.35 , solrad = 1.0, shrink = 1.0, bscale option = "anisotropic"
 refined solvent parameters: sol_k = 0.35  sol_b = 34.4952
>>>> Overall R-value for test set: 0.215237
>>>> Overall R-value for working set: 0.205601

 trying solvent model with fixed k_sol = 0.36 , solrad = 1.0, shrink = 1.0, bscale option = "anisotropic"
 refined solvent parameters: sol_k = 0.36  sol_b = 36.6785
>>>> Overall R-value for test set: 0.215127
>>>> Overall R-value for working set: 0.205268

 trying solvent model with fixed k_sol = 0.37 , solrad = 1.0, shrink = 1.0, bscale option = "anisotropic"
 refined solvent parameters: sol_k = 0.37  sol_b = 39.1418
>>>> Overall R-value for test set: 0.215032
>>>> Overall R-value for working set: 0.205082

 trying solvent model with fixed k_sol = 0.38 , solrad = 1.0, shrink = 1.0, bscale option = "anisotropic"
 refined solvent parameters: sol_k = 0.38  sol_b = 40.9832
>>>> Overall R-value for test set: 0.214911
>>>> Overall R-value for working set: 0.204931

 trying solvent model with fixed k_sol = 0.4 , solrad = 1.0, shrink = 1.0, bscale option = "anisotropic"
 refined solvent parameters: sol_k = 0.4  sol_b = 44.3034
>>>> Overall R-value for test set: 0.215049
>>>> Overall R-value for working set: 0.204622

 trying solvent model with fixed k_sol = 0.42 , solrad = 1.0, shrink = 1.0, bscale option = "anisotropic"
 refined solvent parameters: sol_k = 0.42  sol_b = 48.4875
>>>> Overall R-value for test set: 0.215225
>>>> Overall R-value for working set: 0.2046

 trying solvent model with fixed k_sol = 0.45 , solrad = 1.0, shrink = 1.0, bscale option = "anisotropic"
 refined solvent parameters: sol_k = 0.45  sol_b = 54.963
>>>> Overall R-value for test set: 0.215124
>>>> Overall R-value for working set: 0.204884

 trying solvent model with fixed k_sol = 0.5 , solrad = 1.0, shrink = 1.0, bscale option = "anisotropic"
 refined solvent parameters: sol_k = 0.5  sol_b = 73.4118
>>>> Overall R-value for test set: 0.21619
>>>> Overall R-value for working set: 0.206316

 trying solvent model with fixed k_sol = 0.6 , solrad = 1.0, shrink = 1.0, bscale option = "anisotropic"
 refined solvent parameters: sol_k = 0.6  sol_b = 104.208
>>>> Overall R-value for test set: 0.222203
>>>> Overall R-value for working set: 0.211539

 now recomputing solvent model for best parameters
 best sol_k = 0.42
 best sol_b = 48.4875
 Note: isotropic scaling is now applied to Fcalc = -3.330885E-02

 using fixed solvent parameters: sol_k = 0.42  sol_b = 48.4875

 Solvent model and B-scaling completed
 Solvent model sol_k = 0.42
 Solvent model sol_b = 48.4875
 Solvent model solrad = 1
 Solvent model shrink = 1
 The isotropic component of B scaling ( -3.330101E-02 ) has been added to the isotropic B-factors of the atomic model.
 The isotropic component was removed from the anisotropic tensor, resulting in Ucart (anisotropic B-tensor of the atomic model):
 Ucart_11=  -2.160 Ucart_22=   0.296 Ucart_33=   1.865 Ucart_12=  -0.000 Ucart_13=   2.032 Ucart_23=  -0.000

 CNSsolve> 
 CNSsolve> 
 CNSsolve> 
 CNSsolve> xray 
 XRAY>   @@CNS_XTALMODULE:calculate_r ( 
 ASSFIL: file calculate_r opened.
 XRAY>! Module file: calculate_r 
 XRAY>! 
 XRAY>! CNS module 
 XRAY>! ************ 
 XRAY>! 
 XRAY>! Authors: Axel Brunger and Paul Adams 
 XRAY>! 
 XRAY>! copyright Yale University 
 XRAY>! 
 XRAY>! Function: 
 XRAY>!    Calculates crystallographic R-values 
 XRAY>! 
 XRAY>! Requirements: 
 XRAY>!    Needs to be called within xray 
 XRAY> 
 XRAY>module {calculate_r} 
 MODULE-DECLARATION> 
 MODULE-DECLARATION>( 
 MODULE-DECLARATION>&fobs=fobs; 
 MODULE-DECLARATION>&fcalc=fcalc; 
 MODULE-DECLARATION>&fpart=fpart; 
 MODULE-DECLARATION>&sel=all; 
 MODULE-DECLARATION>&sel_test=none; 
 MODULE-DECLARATION> 
 MODULE-DECLARATION>&print=false;  ! if true, writes R value distributions as a function of resolution to the file specified by "&output" 
 MODULE-DECLARATION>               ! if false, only writes the overall R values to &output 
 MODULE-DECLARATION> 
 MODULE-DECLARATION>&output=OUTPUT; 
 MODULE-DECLARATION>&r=$r; 
 MODULE-DECLARATION>&test_r=$test_r; 
 MODULE-DECLARATION> 
 MODULE-DECLARATION>&calc_r_stats=false; !flag indicating to compute compound symbol that contains the R value distribution and completeness 
 MODULE-DECLARATION>&r_stats=$r_stats;   !compound symbol that contains R value distributions and completeness 
 MODULE-DECLARATION>!  r_stats.nbins           ! number of bins 
 MODULE-DECLARATION>!  r_stats.<i>.high        ! high resolution limit for bin <i> 
 MODULE-DECLARATION>!  r_stats.<i>.low         ! low resolution limit for bin <i> 
 MODULE-DECLARATION>!  r_stats.<i>.nref_work   ! number of reflections in working set for bin <i> 
 MODULE-DECLARATION>!  r_stats.<i>.nref_free   ! number of reflections in test set for bin <i> 
 MODULE-DECLARATION>!  r_stats.<i>.value_comp  ! completeness (work + test set) for bin <i> 
 MODULE-DECLARATION>!  r_stats.<i>.value_work  ! working R value for bin <i> 
 MODULE-DECLARATION>!  r_stats.<i>.value_free  ! free R value for bin <i> 
 MODULE-DECLARATION> 
 MODULE-DECLARATION>) 
 MODULE-INVOCATION>                                 fobs=&STRIP%obs_f; 
 &_2_FOBS set to &STRIP%_1_OBS_F 
 MODULE-INVOCATION>                                 fcalc=fcalc; 
 &_2_FCALC set to fcalc 
 MODULE-INVOCATION>                                 fpart=fbulk; 
 &_2_FPART set to fbulk 
 MODULE-INVOCATION>                                 sel=( ref_active=1 ); 
 &_2_SEL set to ( ref_active = 1 ) 
 MODULE-INVOCATION>                                 sel_test=( tst_active=1 ); 
 &_2_SEL_TEST set to ( tst_active = 1 ) 
 MODULE-INVOCATION>                                 print=true; 
 &_2_PRINT set to true 
 MODULE-INVOCATION>                                 output=OUTPUT; 
 &_2_OUTPUT set to OUTPUT 
 MODULE-INVOCATION>                                 r=$start_r; 
 &_2_R set to $_1_START_R 
 MODULE-INVOCATION>                                 test_r=$start_test_r;) 
 &_2_TEST_R set to $_1_START_TEST_R 
 XRAY> 
 XRAY>set message ? end 
 MESSage=NORM
 XRAY>evaluate ($message_old=$result) 
 EVALUATE: symbol $MESSAGE_OLD set to "NORM" (string)
 XRAY>set echo ? end 
 ECHO=TRUE {ON}
 XRAY>evaluate ($echo_old=$result) 
 EVALUATE: symbol $ECHO_OLD set to TRUE (logical)
 XRAY>if ( $log_level = verbose ) then 
 NEXTCD: condition evaluated as false
 XRAY>  set echo=on message=normal end 
 XRAY>else 
 XRAY>  set echo=off message=off end 
============================================
     R-value by resolution for test set
============================================
 #bin | resolution range | #refl | 
    1   2.74   79.06        432      0.2006
    2   2.17    2.74        426      0.1987
    3   1.90    2.17        433      0.2107
    4   1.73    1.90        451      0.1870
    5   1.60    1.73        444      0.2105
    6   1.51    1.60        436      0.2419
    7   1.43    1.51        412      0.3086
    8   1.37    1.43        408      0.3866
>>>> Overall R-value for test set: 0.215225
============================================
    R-value by resolution for working set
============================================
 #bin | resolution range | #refl | 
    1   2.74   79.06       8351      0.1908
    2   2.17    2.74       8223      0.1847
    3   1.90    2.17       8135      0.1857
    4   1.73    1.90       8096      0.1784
    5   1.60    1.73       8016      0.2019
    6   1.51    1.60       7932      0.2438
    7   1.43    1.51       7867      0.3102
    8   1.37    1.43       7620      0.4112
>>>> Overall R-value for working set: 0.2046
 XRAY> end 
 CNSsolve> 
 CNSsolve> {- check the gridding again since the minimum B-factor may have changed -} 
 CNSsolve> show min ( b ) ( &atom_select ) 
 SELRPN:   3020 atoms have been selected out of   3020
 SHOW: minimum of selected elements =       5.966699
 CNSsolve> evaluate ($b_min=$result) 
 EVALUATE: symbol $B_MIN set to    5.96670     (real)
 CNSsolve> @@CNS_XTALMODULE:fft_parameter_check ( 
 ASSFIL: file fft_parameter_check opened.
 CNSsolve>! Module file: fft_parameter_check 
 CNSsolve>! 
 CNSsolve>! Function: determines the optimum setting for the B-factor inflation 
 CNSsolve>! given the high resolution limit, the gridding factor, and the minimum 
 CNSsolve>! B-factor of the model.   It also determines the recommended ELIM parameter 
 CNSsolve>! as a function of the high resolution limit. 
 CNSsolve>! 
 CNSsolve>! Reference: 
 CNSsolve>! 
 CNSsolve>! Gerard Bricogne (2001), 
 CNSsolve>!   International Tables for Crystallography, Volume B, 2001, p. 87 
 CNSsolve>! 
 CNSsolve>! CNS module 
 CNSsolve>! ********** 
 CNSsolve>! 
 CNSsolve>! Authors: Axel T. Brunger and Paul D. Adams 
 CNSsolve>! 
 CNSsolve>! copyright Yale University 
 CNSsolve>! 
 CNSsolve>! Requirements: 
 CNSsolve>! This module can only be used from the main level of CNS. 
 CNSsolve>! 
 CNSsolve>! 08/03/06 ATB 
 CNSsolve> 
 CNSsolve>module {fft_parameter_check} 
 MODULE-DECLARATION>( 
 MODULE-DECLARATION> &b_min=0;              {input: minimum B-factor of model} 
 MODULE-DECLARATION> &d_min=1.0;            {input: high resolution limit} 
 MODULE-DECLARATION> &q_factor=100;         {input: quality factor - 100 for 1% accuracy} 
 MODULE-DECLARATION> &grid=auto;            {input: if "auto" gridding factor is set automatically} 
 MODULE-DECLARATION>                        {       otherwise gridding factor set to <number>  } 
 MODULE-DECLARATION> &fft_memory=-1;        {input: fft memory; if "-1" use automatic mode } 
 MODULE-DECLARATION> 
 MODULE-DECLARATION> &fft_grid=$fft_grid;   {output: fft gridding factor} 
 MODULE-DECLARATION> &fft_b_add=$fft_b_add; {output: fft B addition} 
 MODULE-DECLARATION> &fft_elim=$fft_elim;   {output: fft elimit factor} 
 MODULE-DECLARATION> 
 MODULE-DECLARATION>) 
 MODULE-INVOCATION>                             d_min=&high_res; 
 &_2_D_MIN set to &_1_HIGH_RES 
 MODULE-INVOCATION>                             b_min=$b_min; 
 &_2_B_MIN set to $_1_B_MIN 
 MODULE-INVOCATION>                             grid=auto; 
 &_2_GRID set to auto 
 MODULE-INVOCATION>                             fft_memory=&fft_memory; 
 &_2_FFT_MEMORY set to &_1_FFT_MEMORY 
 MODULE-INVOCATION>                             fft_grid=$fft_grid; 
 &_2_FFT_GRID set to $_1_FFT_GRID 
 MODULE-INVOCATION>                             fft_b_add=$fft_b_add; 
 &_2_FFT_B_ADD set to $_1_FFT_B_ADD 
 MODULE-INVOCATION>                             fft_elim=$fft_elim; 
 &_2_FFT_ELIM set to $_1_FFT_ELIM 
 MODULE-INVOCATION>                                      ) 
 CNSsolve> 
 CNSsolve> set message ? end 
 MESSage=NORM
 CNSsolve> evaluate ($message_old=$result) 
 EVALUATE: symbol $MESSAGE_OLD set to "NORM" (string)
 CNSsolve> set echo ? end 
 ECHO=TRUE {ON}
 CNSsolve> evaluate ($echo_old=$result) 
 EVALUATE: symbol $ECHO_OLD set to TRUE (logical)
 CNSsolve> if ( $log_level = verbose ) then 
 NEXTCD: condition evaluated as false
 CNSsolve>   set echo=on message=normal end 
 CNSsolve> else 
 CNSsolve>   set echo=off message=off end 
 fft_parameter_check: using automatic memory option
 fft_parameter_check: minimum model B-factor = 5.9667  A^2
 fft_parameter_check: high resolution limit = 1.37  A
 fft_parameter_check: fft gridding factor set to 0.3333
 fft_parameter_check: fft B factor offset set to 0  A^2
 fft_parameter_check: fft Elimit factor set to 10
 CNSsolve> 
 CNSsolve>{- END MODIFICATION -} 
 CNSsolve> 
 CNSsolve> xray 
 XRAY>   @@CNS_XTALMODULE:refinementtarget (target=&reftarget; 
 ASSFIL: file refinementtarget opened.
 XRAY>! Module file: refinementtarget 
 XRAY>! 
 XRAY>! CNS module 
 XRAY>! ********** 
 XRAY>! 
 XRAY>! Authors: Axel Brunger and Paul Adams 
 XRAY>! 
 XRAY>! copyright Yale University 
 XRAY>! 
 XRAY>! Function: 
 XRAY>!    Defines the crystallographic refinement targets 
 XRAY>! 
 XRAY>! Requirements: 
 XRAY>!    Needs to be called within xray 
 XRAY> 
 XRAY>module {refinementtarget} 
 MODULE-DECLARATION> 
 MODULE-DECLARATION>( 
 MODULE-DECLARATION>  &target="residual";    {string} 
 MODULE-DECLARATION>  &sig_sigacv=0.07;      {real} 
 MODULE-DECLARATION>  &mbins=10;             {real} 
 MODULE-DECLARATION>  &fobs=fobs;            {reciprocal space array} 
 MODULE-DECLARATION>  &sigma=sigma;          {reciprocal space array} 
 MODULE-DECLARATION>  &weight=weight;        {reciprocal space array} 
 MODULE-DECLARATION>  &iobs=iobs;            {reciprocal space array} 
 MODULE-DECLARATION>  &sigi=sigi;            {reciprocal space array} 
 MODULE-DECLARATION>  &test=test;            {reciprocal space array} 
 MODULE-DECLARATION>  &fcalc=fcalc;          {reciprocal space array} 
 MODULE-DECLARATION>  &fpart=fpart;          {reciprocal space array} 
 MODULE-DECLARATION>  &pa=pa;                {reciprocal space array} 
 MODULE-DECLARATION>  &pb=pb;                {reciprocal space array} 
 MODULE-DECLARATION>  &pc=pc;                {reciprocal space array} 
 MODULE-DECLARATION>  &pd=pd;                {reciprocal space array} 
 MODULE-DECLARATION>  &phase=phase;          {reciprocal space array} 
 MODULE-DECLARATION>  &fom=fom;              {reciprocal space array} 
 MODULE-DECLARATION>  &sel=all;              {selection} 
 MODULE-DECLARATION>  &sel_test=none;        {selection} 
 MODULE-DECLARATION>  &statistics=false;     {logical} 
 MODULE-DECLARATION>) 
 &_2_TARGET set to &_1_REFTARGET 
 MODULE-INVOCATION>                                     sig_sigacv=0.07; 
 &_2_SIG_SIGACV set to 0.07 
 MODULE-INVOCATION>                                     mbins=&target_bins; 
 &_2_MBINS set to &_1_TARGET_BINS 
 MODULE-INVOCATION>                                     fobs=&STRIP%obs_f; 
 &_2_FOBS set to &STRIP%_1_OBS_F 
 MODULE-INVOCATION>                                     sigma=&STRIP%obs_sigf; 
 &_2_SIGMA set to &STRIP%_1_OBS_SIGF 
 MODULE-INVOCATION>                                     weight=$STRIP%obs_w; 
 &_2_WEIGHT set to $STRIP%_1_OBS_W 
 MODULE-INVOCATION>                                     iobs=$STRIP%obs_i; 
 &_2_IOBS set to $STRIP%_1_OBS_I 
 MODULE-INVOCATION>                                     sigi=$STRIP%obs_sigi; 
 &_2_SIGI set to $STRIP%_1_OBS_SIGI 
 MODULE-INVOCATION>                                     test=tst_active; 
 &_2_TEST set to tst_active 
 MODULE-INVOCATION>                                     fcalc=fcalc; 
 &_2_FCALC set to fcalc 
 MODULE-INVOCATION>                                     fpart=fbulk; 
 &_2_FPART set to fbulk 
 MODULE-INVOCATION>                                     pa=&STRIP%obs_pa; 
 &_2_PA set to &STRIP%_1_OBS_PA 
 MODULE-INVOCATION>                                     pb=&STRIP%obs_pb; 
 &_2_PB set to &STRIP%_1_OBS_PB 
 MODULE-INVOCATION>                                     pc=&STRIP%obs_pc; 
 &_2_PC set to &STRIP%_1_OBS_PC 
 MODULE-INVOCATION>                                     pd=&STRIP%obs_pd; 
 &_2_PD set to &STRIP%_1_OBS_PD 
 MODULE-INVOCATION>                                     phase=&STRIP%obs_phase; 
 &_2_PHASE set to &STRIP%_1_OBS_PHASE 
 MODULE-INVOCATION>                                     fom=&STRIP%obs_fom; 
 &_2_FOM set to &STRIP%_1_OBS_FOM 
 MODULE-INVOCATION>                                     sel=(ref_active=1); 
 &_2_SEL set to ( ref_active = 1 ) 
 MODULE-INVOCATION>                                     sel_test=(tst_active=1); 
 &_2_SEL_TEST set to ( tst_active = 1 ) 
 MODULE-INVOCATION>                                     statistics=true;) 
 &_2_STATISTICS set to true 
 XRAY> 
 XRAY>set message ? end 
 MESSage=NORM
 XRAY>evaluate ($message_old=$result) 
 EVALUATE: symbol $MESSAGE_OLD set to "NORM" (string)
 XRAY>set echo ? end 
 ECHO=TRUE {ON}
 XRAY>evaluate ($echo_old=$result) 
 EVALUATE: symbol $ECHO_OLD set to TRUE (logical)
 XRAY>if ( $log_level = verbose ) then 
 NEXTCD: condition evaluated as false
 XRAY>  set echo=on message=normal end 
 XRAY>else 
 XRAY>  set echo=off message=off end 
 XSIGMAACV: Overall sigma for line restraint is       0.07000000
 XSIGMAACV: step limit reached
 XSIGMAACV: Refinement of SIGMAA has finished 
            Overall mean FOM is   0.88712

 sigmaA statistics                   sigmaA   sigmaD     Delta     <Eobs^2>  <Ecalc^2>
 #bin | resolution range | #refl | 
    1   5.05   79.06       1429      0.9459  109.6201    0.5163    0.9983    0.9977
    2   4.01    5.05       1392      0.9599  125.5999    0.5645    0.9990    0.9987
    3   3.50    4.01       1419      0.9510  139.2551    0.5755    0.9997    0.9998
    4   3.18    3.50       1399      0.9459  107.5808    0.5738    0.9986    0.9983
    5   2.95    3.18       1391      0.9197  103.2993    0.5557    1.0000    1.0000
    6   2.78    2.95       1398      0.9674   67.2050    0.5876    0.9999    0.9999
    7   2.64    2.78       1382      0.9477   74.5398    0.5907    0.9998    0.9999
    8   2.52    2.64       1411      0.9561   62.2342    0.6098    0.9996    0.9992
    9   2.43    2.52       1399      0.9572   59.0975    0.5923    1.0000    1.0000
   10   2.34    2.43       1373      0.9579   63.6126    0.6059    0.9990    0.9991
   11   2.27    2.34       1366      0.9587   60.8615    0.6286    1.0000    1.0000
   12   2.20    2.27       1384      0.9582   56.0263    0.6384    0.9999    0.9998
   13   2.15    2.20       1371      0.9517   57.1855    0.6251    1.0000    1.0000
   14   2.09    2.15       1404      0.9386   51.6566    0.6099    0.9992    0.9991
   15   2.05    2.09       1362      0.9565   46.3498    0.6047    1.0000    1.0000
   16   2.00    2.05       1362      0.9560   48.2638    0.6361    0.9997    0.9996
   17   1.96    2.00       1361      0.9584   41.3755    0.6226    1.0000    1.0000
   18   1.93    1.96       1390      0.9570   38.5104    0.6476    1.0000    1.0000
   19   1.89    1.93       1365      0.9470   35.0644    0.5778    0.9999    0.9997
   20   1.86    1.89       1388      0.9652   29.4778    0.6141    1.0000    1.0000
   21   1.83    1.86       1334      0.9532   32.1798    0.5827    1.0000    1.0000
   22   1.80    1.83       1380      0.9552   31.0254    0.5622    0.9995    0.9996
   23   1.77    1.80       1368      0.9390   31.5072    0.5325    1.0000    1.0000
   24   1.75    1.77       1337      0.9513   28.1068    0.5511    1.0000    1.0000
   25   1.73    1.75       1382      0.9568   26.4780    0.5912    0.9995    0.9995
   26   1.70    1.73       1351      0.9441   27.0167    0.5402    1.0000    1.0000
   27   1.68    1.70       1343      0.9395   26.5007    0.5529    1.0000    1.0000
   28   1.66    1.68       1391      0.9302   25.5472    0.5493    1.0000    1.0000
   29   1.64    1.66       1321      0.9441   24.4498    0.5402    0.9988    0.9993
   30   1.62    1.64       1366      0.9476   21.2286    0.5231    1.0000    1.0000
   31   1.61    1.62       1375      0.9366   25.6398    0.5213    1.0000    1.0000
   32   1.59    1.61       1304      0.9405   24.5893    0.5379    1.0000    1.0000
   33   1.57    1.59       1346      0.9287   23.4883    0.5311    1.0000    1.0000
   34   1.56    1.57       1359      0.9246   21.6223    0.5079    1.0000    1.0000
   35   1.54    1.56       1317      0.9162   24.1837    0.4816    1.0000    1.0000
   36   1.53    1.54       1316      0.9294   20.2716    0.4902    1.0000    1.0000
   37   1.51    1.53       1346      0.9442   19.1358    0.4762    1.0000    1.0000
   38   1.50    1.51       1354      0.9330   18.3025    0.4934    1.0000    1.0000
   39   1.49    1.50       1320      0.9168   20.3007    0.5093    1.0000    1.0000
   40   1.48    1.49       1318      0.9137   20.5662    0.4779    1.0000    1.0000
   41   1.46    1.48       1321      0.8809   22.8177    0.4476    1.0000    1.0000
   42   1.45    1.46       1376      0.9162   19.9044    0.4515    1.0000    1.0000
   43   1.44    1.45       1258      0.8790   20.3994    0.4418    1.0000    1.0000
   44   1.43    1.44       1343      0.8561   21.3514    0.3965    1.0000    1.0000
   45   1.42    1.43       1305      0.8408   20.9253    0.3928    1.0000    1.0000
   46   1.41    1.42       1326      0.7739   22.9656    0.3942    1.0000    1.0000
   47   1.40    1.41       1286      0.7910   22.4729    0.3815    1.0000    1.0000
   48   1.39    1.40       1247      0.8192   21.8875    0.3636    1.0000    1.0000
   49   1.38    1.39       1313      0.8152   21.1851    0.4077    1.0000    1.0000
   50   1.37    1.38       1233      0.7975   21.0492    0.3906    1.0000    1.0000
 XRAY> end 
 CNSsolve> 
 CNSsolve> @@CNS_XTALMODULE:one_term_wa (wa=$wa;) 
 ASSFIL: file one_term_wa opened.
 CNSsolve>! Module file: one_term_wa 
 CNSsolve>! 
 CNSsolve>! CNS module 
 CNSsolve>! ********** 
 CNSsolve>! 
 CNSsolve>! Authors: Axel T. Brunger and Paul Adams 
 CNSsolve>! 
 CNSsolve>! copyright Yale University 
 CNSsolve>! 
 CNSsolve>! Function: 
 CNSsolve>!    Calculate the weight for the crystallographic energy term 
 CNSsolve>!    normalized such that rmsF * wa = 10 (empirical value) 
 CNSsolve>! 
 CNSsolve>! Requirements: 
 CNSsolve>!    To be called from the main level 
 CNSsolve> 
 CNSsolve>module {one_term_wa} 
 MODULE-DECLARATION>( 
 MODULE-DECLARATION>  &wa=$wa_temp; 
 MODULE-DECLARATION>) 
 &_2_WA set to $_1_WA 
 CNSsolve> 
 CNSsolve>set message ? end 
 MESSage=NORM
 CNSsolve>evaluate ($message_old=$result) 
 EVALUATE: symbol $MESSAGE_OLD set to "NORM" (string)
 CNSsolve>set echo ? end 
 ECHO=TRUE {ON}
 CNSsolve>evaluate ($echo_old=$result) 
 EVALUATE: symbol $ECHO_OLD set to TRUE (logical)
 CNSsolve>if ( $log_level = verbose ) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  set echo=on message=normal end 
 CNSsolve>else 
 CNSsolve>  set echo=off message=off end 
 XTAREXPR: ->[TEST SET]    monitor=  0.215
 XTAREXPR: ->[WORKING SET] monitor=  0.205
 --------------- cycle=     1 --------------------------------------------------
 | Etotal =231423.898 grad(E)=19.700     E(XREF)=231423.898                    |
 -------------------------------------------------------------------------------
 one_term_wa: optimal value for wa= 0.507612
 CNSsolve> 
 CNSsolve> xray 
 XRAY>    @@CNS_XTALMODULE:calculate_r (fobs=&STRIP%obs_f; 
 ASSFIL: file calculate_r opened.
 XRAY>! Module file: calculate_r 
 XRAY>! 
 XRAY>! CNS module 
 XRAY>! ************ 
 XRAY>! 
 XRAY>! Authors: Axel Brunger and Paul Adams 
 XRAY>! 
 XRAY>! copyright Yale University 
 XRAY>! 
 XRAY>! Function: 
 XRAY>!    Calculates crystallographic R-values 
 XRAY>! 
 XRAY>! Requirements: 
 XRAY>!    Needs to be called within xray 
 XRAY> 
 XRAY>module {calculate_r} 
 MODULE-DECLARATION> 
 MODULE-DECLARATION>( 
 MODULE-DECLARATION>&fobs=fobs; 
 MODULE-DECLARATION>&fcalc=fcalc; 
 MODULE-DECLARATION>&fpart=fpart; 
 MODULE-DECLARATION>&sel=all; 
 MODULE-DECLARATION>&sel_test=none; 
 MODULE-DECLARATION> 
 MODULE-DECLARATION>&print=false;  ! if true, writes R value distributions as a function of resolution to the file specified by "&output" 
 MODULE-DECLARATION>               ! if false, only writes the overall R values to &output 
 MODULE-DECLARATION> 
 MODULE-DECLARATION>&output=OUTPUT; 
 MODULE-DECLARATION>&r=$r; 
 MODULE-DECLARATION>&test_r=$test_r; 
 MODULE-DECLARATION> 
 MODULE-DECLARATION>&calc_r_stats=false; !flag indicating to compute compound symbol that contains the R value distribution and completeness 
 MODULE-DECLARATION>&r_stats=$r_stats;   !compound symbol that contains R value distributions and completeness 
 MODULE-DECLARATION>!  r_stats.nbins           ! number of bins 
 MODULE-DECLARATION>!  r_stats.<i>.high        ! high resolution limit for bin <i> 
 MODULE-DECLARATION>!  r_stats.<i>.low         ! low resolution limit for bin <i> 
 MODULE-DECLARATION>!  r_stats.<i>.nref_work   ! number of reflections in working set for bin <i> 
 MODULE-DECLARATION>!  r_stats.<i>.nref_free   ! number of reflections in test set for bin <i> 
 MODULE-DECLARATION>!  r_stats.<i>.value_comp  ! completeness (work + test set) for bin <i> 
 MODULE-DECLARATION>!  r_stats.<i>.value_work  ! working R value for bin <i> 
 MODULE-DECLARATION>!  r_stats.<i>.value_free  ! free R value for bin <i> 
 MODULE-DECLARATION> 
 MODULE-DECLARATION>) 
 &_2_FOBS set to &STRIP%_1_OBS_F 
 MODULE-INVOCATION>                                 fcalc=fcalc; 
 &_2_FCALC set to fcalc 
 MODULE-INVOCATION>                                 fpart=fbulk; 
 &_2_FPART set to fbulk 
 MODULE-INVOCATION>                                 sel=(ref_active=1); 
 &_2_SEL set to ( ref_active = 1 ) 
 MODULE-INVOCATION>                                 sel_test=(tst_active=1); 
 &_2_SEL_TEST set to ( tst_active = 1 ) 
 MODULE-INVOCATION>                                 print=true; 
 &_2_PRINT set to true 
 MODULE-INVOCATION>                                 output=OUTPUT; 
 &_2_OUTPUT set to OUTPUT 
 MODULE-INVOCATION>                                 r=$start_r; 
 &_2_R set to $_1_START_R 
 MODULE-INVOCATION>                                 test_r=$start_test_r;) 
 &_2_TEST_R set to $_1_START_TEST_R 
 XRAY> 
 XRAY>set message ? end 
 MESSage=NORM
 XRAY>evaluate ($message_old=$result) 
 EVALUATE: symbol $MESSAGE_OLD set to "NORM" (string)
 XRAY>set echo ? end 
 ECHO=TRUE {ON}
 XRAY>evaluate ($echo_old=$result) 
 EVALUATE: symbol $ECHO_OLD set to TRUE (logical)
 XRAY>if ( $log_level = verbose ) then 
 NEXTCD: condition evaluated as false
 XRAY>  set echo=on message=normal end 
 XRAY>else 
 XRAY>  set echo=off message=off end 
============================================
     R-value by resolution for test set
============================================
 #bin | resolution range | #refl | 
    1   5.05   79.06         88      0.2093
    2   4.01    5.05         64      0.1802
    3   3.50    4.01         78      0.1921
    4   3.18    3.50         77      0.2108
    5   2.95    3.18         53      0.2518
    6   2.78    2.95         59      0.1715
    7   2.64    2.78         72      0.2123
    8   2.52    2.64         73      0.1913
    9   2.43    2.52         60      0.1859
   10   2.34    2.43         76      0.1935
   11   2.27    2.34         64      0.1951
   12   2.20    2.27         72      0.2154
   13   2.15    2.20         51      0.2020
   14   2.09    2.15         65      0.2297
   15   2.05    2.09         69      0.1963
   16   2.00    2.05         89      0.2143
   17   1.96    2.00         69      0.1903
   18   1.93    1.96         73      0.2237
   19   1.89    1.93         64      0.2121
   20   1.86    1.89         75      0.1748
   21   1.83    1.86         63      0.1875
   22   1.80    1.83         98      0.1775
   23   1.77    1.80         70      0.2221
   24   1.75    1.77         59      0.1915
   25   1.73    1.75         61      0.1769
   26   1.70    1.73         62      0.2038
   27   1.68    1.70         71      0.2012
   28   1.66    1.68         77      0.2144
   29   1.64    1.66         64      0.1918
   30   1.62    1.64         80      0.2213
   31   1.61    1.62         79      0.2362
   32   1.59    1.61         64      0.2165
   33   1.57    1.59         81      0.2318
   34   1.56    1.57         67      0.2314
   35   1.54    1.56         70      0.2645
   36   1.53    1.54         64      0.2568
   37   1.51    1.53         66      0.2489
   38   1.50    1.51         69      0.2552
   39   1.49    1.50         62      0.2374
   40   1.48    1.49         69      0.2737
   41   1.46    1.48         70      0.3478
   42   1.45    1.46         70      0.2923
   43   1.44    1.45         61      0.3247
   44   1.43    1.44         61      0.4012
   45   1.42    1.43         77      0.3847
   46   1.41    1.42         69      0.3993
   47   1.40    1.41         61      0.4078
   48   1.39    1.40         59      0.4108
   49   1.38    1.39         67      0.3564
   50   1.37    1.38         60      0.3848
>>>> Overall R-value for test set: 0.215225
============================================
    R-value by resolution for working set
============================================
 #bin | resolution range | #refl | 
    1   5.05   79.06       1341      0.2340
    2   4.01    5.05       1328      0.1849
    3   3.50    4.01       1341      0.1747
    4   3.18    3.50       1322      0.1796
    5   2.95    3.18       1338      0.1938
    6   2.78    2.95       1339      0.1863
    7   2.64    2.78       1310      0.1768
    8   2.52    2.64       1338      0.1821
    9   2.43    2.52       1339      0.1800
   10   2.34    2.43       1297      0.1861
   11   2.27    2.34       1302      0.1874
   12   2.20    2.27       1312      0.1936
   13   2.15    2.20       1320      0.1913
   14   2.09    2.15       1339      0.1859
   15   2.05    2.09       1293      0.1892
   16   2.00    2.05       1273      0.1882
   17   1.96    2.00       1292      0.1878
   18   1.93    1.96       1317      0.1803
   19   1.89    1.93       1301      0.1722
   20   1.86    1.89       1313      0.1765
   21   1.83    1.86       1271      0.1676
   22   1.80    1.83       1282      0.1785
   23   1.77    1.80       1298      0.1793
   24   1.75    1.77       1278      0.1863
   25   1.73    1.75       1321      0.1878
   26   1.70    1.73       1289      0.1945
   27   1.68    1.70       1272      0.2002
   28   1.66    1.68       1314      0.1983
   29   1.64    1.66       1257      0.2037
   30   1.62    1.64       1286      0.2006
   31   1.61    1.62       1296      0.2152
   32   1.59    1.61       1240      0.2191
   33   1.57    1.59       1265      0.2258
   34   1.56    1.57       1292      0.2383
   35   1.54    1.56       1247      0.2507
   36   1.53    1.54       1252      0.2533
   37   1.51    1.53       1280      0.2673
   38   1.50    1.51       1285      0.2590
   39   1.49    1.50       1258      0.2768
   40   1.48    1.49       1249      0.2976
   41   1.46    1.48       1251      0.2986
   42   1.45    1.46       1306      0.3207
   43   1.44    1.45       1197      0.3480
   44   1.43    1.44       1282      0.3721
   45   1.42    1.43       1228      0.3873
   46   1.41    1.42       1257      0.3996
   47   1.40    1.41       1225      0.3998
   48   1.39    1.40       1188      0.4373
   49   1.38    1.39       1246      0.4370
   50   1.37    1.38       1173      0.4185
>>>> Overall R-value for working set: 0.204601
 XRAY> end 
 CNSsolve> 
 CNSsolve> if (&rweight < 0) then 
 NEXTCD: condition evaluated as true
 CNSsolve>   @@CNS_XTALMODULE:get_rweight (selected=&atom_select; 
 ASSFIL: file get_rweight opened.
 CNSsolve>! Module file: get_rweight 
 CNSsolve>! 
 CNSsolve>! CNS module 
 CNSsolve>! ********** 
 CNSsolve>! 
 CNSsolve>! Authors: Axel T. Brunger and Paul Adams 
 CNSsolve>! 
 CNSsolve>! copyright Yale University 
 CNSsolve>! 
 CNSsolve>! Function: 
 CNSsolve>!    Calculate the weight for the restraint term in 
 CNSsolve>!    individual B-factor refinement 
 CNSsolve>! 
 CNSsolve>! Requirements: 
 CNSsolve>!    To be called from the main level of CNS 
 CNSsolve>!    Uses comparision coordinate set and also vx, vy, vz 
 CNSsolve> 
 CNSsolve>module {get_rweight} 
 MODULE-DECLARATION>( 
 MODULE-DECLARATION>  &selected=(all); 
 MODULE-DECLARATION>  &fixed=(none); 
 MODULE-DECLARATION>  &rweight; 
 MODULE-DECLARATION>) 
 &_2_SELECTED set to &_1_ATOM_SELECT 
 MODULE-INVOCATION>                                 fixed=&atom_fixed; 
 &_2_FIXED set to &_1_ATOM_FIXED 
 MODULE-INVOCATION>                                 rweight=$rweight_current;) 
 &_2_RWEIGHT set to $_1_RWEIGHT_CURRENT 
 CNSsolve> 
 CNSsolve>set message ? end 
 MESSage=NORM
 CNSsolve>evaluate ($message_old=$result) 
 EVALUATE: symbol $MESSAGE_OLD set to "NORM" (string)
 CNSsolve>set echo ? end 
 ECHO=TRUE {ON}
 CNSsolve>evaluate ($echo_old=$result) 
 EVALUATE: symbol $ECHO_OLD set to TRUE (logical)
 CNSsolve>if ( $log_level = verbose ) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  set echo=on message=normal end 
 CNSsolve>else 
 CNSsolve>  set echo=off message=off end 
 --------------- cycle=     2 --------------------------------------------------
 | Etotal =0.000      grad(E)=0.000                                            |
 -------------------------------------------------------------------------------
 XTAREXPR: ->[TEST SET]    monitor=  0.215
 XTAREXPR: ->[WORKING SET] monitor=  0.205
 --------------- cycle=     3 --------------------------------------------------
 | Etotal =117473.548 grad(E)=10.000     E(XREF)=117473.548                    |
 -------------------------------------------------------------------------------
 get_rweight: optimal rweight= 0.1
 CNSsolve> else 
 CNSsolve>   evaluate ($rweight_current=&rweight) 
 CNSsolve> end if 
 CNSsolve> 
 CNSsolve> xray 
 XRAY>   optimize bfactors 
 XROPTI> 
 XROPTI>     method=lbfgs 
 XROPTI> 
 XROPTI>     bmin=&bmin 
 XROPTI>     bmax=&bmax 
 XROPTI> 
 XROPTI>     nstep=&bfactor_nstep 
 XROPTI>     drop=10.0 
 XROPTI> 
 XROPTI>     bsigma=( (&atom_select and not(&atom_fixed)) and &atom_main )=&bsig_main 
 SELRPN:   1656 atoms have been selected out of   3020
 XROPTI>     bsigma=( (&atom_select and not(&atom_fixed)) and 
 SELRPN>               not(&atom_main) )=&bsig_side 
 SELRPN:   1364 atoms have been selected out of   3020
 XROPTI> 
 XROPTI>     asigma=( (&atom_select and not(&atom_fixed)) and &atom_main )=&asig_main 
 SELRPN:   1656 atoms have been selected out of   3020
 XROPTI>     asigma=( (&atom_select and not(&atom_fixed)) and 
 SELRPN>               not(&atom_main) )=&asig_side 
 SELRPN:   1364 atoms have been selected out of   3020
 XROPTI> 
 XROPTI>     rweight=$rweight_current 
 XROPTI>   end 
 XBREF:     3020 individual B-factors will be refined.
 XBSET: There are  2720 bond restraints on B-factors
        Initial sum (bi-bj)/bsigma^2:    1.00350
 XBSET: There are  3681 angle restraints on B-factors
        Initial sum (bi-bj)/asigma^2:    1.22222
 XBRMS: total number of bond B restraints =     2720 ( $BN_BOND   )
 XBRMS: overall rmsd for bond B restraints =    1.891 ( $BRMS_BOND )
 XBRMS: number of bond B restraints for group   1 =     1303 ( $BN_BOND_1   )
 XBRMS: rmsd for bond B restraints for group   1 =    0.977 ( $BRMS_BOND_1 )
 XBRMS: number of bond B restraints for group   2 =     1417 ( $BN_BOND_2   )
 XBRMS: rmsd for bond B restraints for group   2 =    2.447 ( $BRMS_BOND_2 )
 XBRMS: total number of angle B restraints =     3681 ( $BN_ANGL   )
 XBRMS: overall rmsd for angle B restraints =    2.875 ( $BRMS_ANGL )
 XBRMS: number of angle B restraints for group   1 =     1627 ( $BN_ANGL_1   )
 XBRMS: rmsd for angle B restraints for group   1 =    1.408 ( $BRMS_ANGL_1 )
 XBRMS: number of angle B restraints for group   2 =     2054 ( $BN_ANGL_2   )
 XBRMS: rmsd for angle B restraints for group   2 =    3.638 ( $BRMS_ANGL_2 )
 FCALC: #scatt.=   3020 #anomalous=   0 #special pos.=  0 occupancies=1
 XFFT: using grid [ 125, 180, 180] and sublattice [ 125( 125), 180( 181),  60]
 XTAREXPR: ->[TEST SET]    monitor=  0.215
 XTAREXPR: ->[WORKING SET] monitor=  0.205
 --------------- cycle=     1 --------------------------------------------------
 | Target= 0.118E+06 E(XREF)= 0.117E+06  E(BRES)= 0.824E+04  E(grad)= 0.197E+00|
 -------------------------------------------------------------------------------
 FCALC: #scatt.=   3020 #anomalous=   0 #special pos.=  0 occupancies=1
 XFFT: using grid [ 125, 180, 180] and sublattice [ 125( 125), 180( 181),  60]
 XTAREXPR: ->[TEST SET]    monitor=  0.215
 XTAREXPR: ->[WORKING SET] monitor=  0.205
 --------------- cycle=     2 --------------------------------------------------
 | Target= 0.118E+06 E(XREF)= 0.117E+06  E(BRES)= 0.822E+04  E(grad)= 0.198E+00|
 -------------------------------------------------------------------------------
 FCALC: #scatt.=   3020 #anomalous=   0 #special pos.=  0 occupancies=1
 XFFT: using grid [ 125, 180, 180] and sublattice [ 125( 125), 180( 181),  60]
 XTAREXPR: ->[TEST SET]    monitor=  0.215
 XTAREXPR: ->[WORKING SET] monitor=  0.205
 --------------- cycle=     3 --------------------------------------------------
 | Target= 0.118E+06 E(XREF)= 0.117E+06  E(BRES)= 0.822E+04  E(grad)= 0.198E+00|
 -------------------------------------------------------------------------------
 LBFGS: normal termination - NSTEP limit reached
 XBREF: using the parameters (at cycle      2) which produce the minimum target. 
 XBRMS: total number of bond B restraints =     2720 ( $BN_BOND   )
 XBRMS: overall rmsd for bond B restraints =    1.889 ( $BRMS_BOND )
 XBRMS: number of bond B restraints for group   1 =     1303 ( $BN_BOND_1   )
 XBRMS: rmsd for bond B restraints for group   1 =    0.977 ( $BRMS_BOND_1 )
 XBRMS: number of bond B restraints for group   2 =     1417 ( $BN_BOND_2   )
 XBRMS: rmsd for bond B restraints for group   2 =    2.444 ( $BRMS_BOND_2 )
 XBRMS: total number of angle B restraints =     3681 ( $BN_ANGL   )
 XBRMS: overall rmsd for angle B restraints =    2.871 ( $BRMS_ANGL )
 XBRMS: number of angle B restraints for group   1 =     1627 ( $BN_ANGL_1   )
 XBRMS: rmsd for angle B restraints for group   1 =    1.408 ( $BRMS_ANGL_1 )
 XBRMS: number of angle B restraints for group   2 =     2054 ( $BN_ANGL_2   )
 XBRMS: rmsd for angle B restraints for group   2 =    3.633 ( $BRMS_ANGL_2 )
 XRAY> end 
 CNSsolve> 
 CNSsolve> xray 
 XRAY>    predict 
 PREDict>      mode=reciprocal 
 PREDict>      to=fcalc 
 PREDict>      selection=(ref_active=1) 
 Total of     67682 structure factor elements were selected.
 PREDict>      atomselection=( &atom_select ) 
 SELRPN:   3020 atoms have been selected out of   3020
 PREDict>    end 
 FCALC: #scatt.=   3020 #anomalous=   0 #special pos.=  0 occupancies=1
 XFFT: using grid [ 125, 180, 180] and sublattice [ 125( 125), 180( 181),  60]
 XRAY>    @@CNS_XTALMODULE:calculate_r (fobs=&STRIP%obs_f; 
 ASSFIL: file calculate_r opened.
 XRAY>! Module file: calculate_r 
 XRAY>! 
 XRAY>! CNS module 
 XRAY>! ************ 
 XRAY>! 
 XRAY>! Authors: Axel Brunger and Paul Adams 
 XRAY>! 
 XRAY>! copyright Yale University 
 XRAY>! 
 XRAY>! Function: 
 XRAY>!    Calculates crystallographic R-values 
 XRAY>! 
 XRAY>! Requirements: 
 XRAY>!    Needs to be called within xray 
 XRAY> 
 XRAY>module {calculate_r} 
 MODULE-DECLARATION> 
 MODULE-DECLARATION>( 
 MODULE-DECLARATION>&fobs=fobs; 
 MODULE-DECLARATION>&fcalc=fcalc; 
 MODULE-DECLARATION>&fpart=fpart; 
 MODULE-DECLARATION>&sel=all; 
 MODULE-DECLARATION>&sel_test=none; 
 MODULE-DECLARATION> 
 MODULE-DECLARATION>&print=false;  ! if true, writes R value distributions as a function of resolution to the file specified by "&output" 
 MODULE-DECLARATION>               ! if false, only writes the overall R values to &output 
 MODULE-DECLARATION> 
 MODULE-DECLARATION>&output=OUTPUT; 
 MODULE-DECLARATION>&r=$r; 
 MODULE-DECLARATION>&test_r=$test_r; 
 MODULE-DECLARATION> 
 MODULE-DECLARATION>&calc_r_stats=false; !flag indicating to compute compound symbol that contains the R value distribution and completeness 
 MODULE-DECLARATION>&r_stats=$r_stats;   !compound symbol that contains R value distributions and completeness 
 MODULE-DECLARATION>!  r_stats.nbins           ! number of bins 
 MODULE-DECLARATION>!  r_stats.<i>.high        ! high resolution limit for bin <i> 
 MODULE-DECLARATION>!  r_stats.<i>.low         ! low resolution limit for bin <i> 
 MODULE-DECLARATION>!  r_stats.<i>.nref_work   ! number of reflections in working set for bin <i> 
 MODULE-DECLARATION>!  r_stats.<i>.nref_free   ! number of reflections in test set for bin <i> 
 MODULE-DECLARATION>!  r_stats.<i>.value_comp  ! completeness (work + test set) for bin <i> 
 MODULE-DECLARATION>!  r_stats.<i>.value_work  ! working R value for bin <i> 
 MODULE-DECLARATION>!  r_stats.<i>.value_free  ! free R value for bin <i> 
 MODULE-DECLARATION> 
 MODULE-DECLARATION>) 
 &_2_FOBS set to &STRIP%_1_OBS_F 
 MODULE-INVOCATION>                                 fcalc=fcalc; 
 &_2_FCALC set to fcalc 
 MODULE-INVOCATION>                                 fpart=fbulk; 
 &_2_FPART set to fbulk 
 MODULE-INVOCATION>                                 sel=(ref_active=1); 
 &_2_SEL set to ( ref_active = 1 ) 
 MODULE-INVOCATION>                                 sel_test=(tst_active=1); 
 &_2_SEL_TEST set to ( tst_active = 1 ) 
 MODULE-INVOCATION>                                 print=true; 
 &_2_PRINT set to true 
 MODULE-INVOCATION>                                 output=OUTPUT; 
 &_2_OUTPUT set to OUTPUT 
 MODULE-INVOCATION>                                 r=$full_r; 
 &_2_R set to $_1_FULL_R 
 MODULE-INVOCATION>                                 test_r=$full_test_r;) 
 &_2_TEST_R set to $_1_FULL_TEST_R 
 XRAY> 
 XRAY>set message ? end 
 MESSage=NORM
 XRAY>evaluate ($message_old=$result) 
 EVALUATE: symbol $MESSAGE_OLD set to "NORM" (string)
 XRAY>set echo ? end 
 ECHO=TRUE {ON}
 XRAY>evaluate ($echo_old=$result) 
 EVALUATE: symbol $ECHO_OLD set to TRUE (logical)
 XRAY>if ( $log_level = verbose ) then 
 NEXTCD: condition evaluated as false
 XRAY>  set echo=on message=normal end 
 XRAY>else 
 XRAY>  set echo=off message=off end 
============================================
     R-value by resolution for test set
============================================
 #bin | resolution range | #refl | 
    1   5.05   79.06         88      0.2093
    2   4.01    5.05         64      0.1802
    3   3.50    4.01         78      0.1923
    4   3.18    3.50         77      0.2107
    5   2.95    3.18         53      0.2517
    6   2.78    2.95         59      0.1716
    7   2.64    2.78         72      0.2125
    8   2.52    2.64         73      0.1911
    9   2.43    2.52         60      0.1859
   10   2.34    2.43         76      0.1935
   11   2.27    2.34         64      0.1953
   12   2.20    2.27         72      0.2154
   13   2.15    2.20         51      0.2021
   14   2.09    2.15         65      0.2300
   15   2.05    2.09         69      0.1966
   16   2.00    2.05         89      0.2141
   17   1.96    2.00         69      0.1901
   18   1.93    1.96         73      0.2241
   19   1.89    1.93         64      0.2120
   20   1.86    1.89         75      0.1749
   21   1.83    1.86         63      0.1882
   22   1.80    1.83         98      0.1780
   23   1.77    1.80         70      0.2216
   24   1.75    1.77         59      0.1913
   25   1.73    1.75         61      0.1763
   26   1.70    1.73         62      0.2037
   27   1.68    1.70         71      0.2012
   28   1.66    1.68         77      0.2143
   29   1.64    1.66         64      0.1921
   30   1.62    1.64         80      0.2218
   31   1.61    1.62         79      0.2367
   32   1.59    1.61         64      0.2170
   33   1.57    1.59         81      0.2310
   34   1.56    1.57         67      0.2312
   35   1.54    1.56         70      0.2637
   36   1.53    1.54         64      0.2566
   37   1.51    1.53         66      0.2493
   38   1.50    1.51         69      0.2553
   39   1.49    1.50         62      0.2367
   40   1.48    1.49         69      0.2739
   41   1.46    1.48         70      0.3477
   42   1.45    1.46         70      0.2932
   43   1.44    1.45         61      0.3265
   44   1.43    1.44         61      0.4016
   45   1.42    1.43         77      0.3843
   46   1.41    1.42         69      0.3986
   47   1.40    1.41         61      0.4061
   48   1.39    1.40         59      0.4098
   49   1.38    1.39         67      0.3556
   50   1.37    1.38         60      0.3859
>>>> Overall R-value for test set: 0.215266
============================================
    R-value by resolution for working set
============================================
 #bin | resolution range | #refl | 
    1   5.05   79.06       1341      0.2341
    2   4.01    5.05       1328      0.1850
    3   3.50    4.01       1341      0.1747
    4   3.18    3.50       1322      0.1797
    5   2.95    3.18       1338      0.1938
    6   2.78    2.95       1339      0.1863
    7   2.64    2.78       1310      0.1769
    8   2.52    2.64       1338      0.1821
    9   2.43    2.52       1339      0.1799
   10   2.34    2.43       1297      0.1860
   11   2.27    2.34       1302      0.1874
   12   2.20    2.27       1312      0.1936
   13   2.15    2.20       1320      0.1913
   14   2.09    2.15       1339      0.1860
   15   2.05    2.09       1293      0.1893
   16   2.00    2.05       1273      0.1881
   17   1.96    2.00       1292      0.1878
   18   1.93    1.96       1317      0.1803
   19   1.89    1.93       1301      0.1721
   20   1.86    1.89       1313      0.1765
   21   1.83    1.86       1271      0.1675
   22   1.80    1.83       1282      0.1785
   23   1.77    1.80       1298      0.1792
   24   1.75    1.77       1278      0.1863
   25   1.73    1.75       1321      0.1875
   26   1.70    1.73       1289      0.1944
   27   1.68    1.70       1272      0.2000
   28   1.66    1.68       1314      0.1981
   29   1.64    1.66       1257      0.2037
   30   1.62    1.64       1286      0.2008
   31   1.61    1.62       1296      0.2153
   32   1.59    1.61       1240      0.2194
   33   1.57    1.59       1265      0.2258
   34   1.56    1.57       1292      0.2385
   35   1.54    1.56       1247      0.2507
   36   1.53    1.54       1252      0.2532
   37   1.51    1.53       1280      0.2671
   38   1.50    1.51       1285      0.2591
   39   1.49    1.50       1258      0.2769
   40   1.48    1.49       1249      0.2973
   41   1.46    1.48       1251      0.2984
   42   1.45    1.46       1306      0.3208
   43   1.44    1.45       1197      0.3480
   44   1.43    1.44       1282      0.3722
   45   1.42    1.43       1228      0.3877
   46   1.41    1.42       1257      0.3996
   47   1.40    1.41       1225      0.4003
   48   1.39    1.40       1188      0.4370
   49   1.38    1.39       1246      0.4373
   50   1.37    1.38       1173      0.4184
>>>> Overall R-value for working set: 0.204607
 XRAY> end 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>{GAUCNS Print energy to file mmen4} 
 CNSsolve>set display=mmen4 end 
 ASSFIL: file mmen4 opened.
 CNSsolve>energy end 
 FCALC: #scatt.=   3020 #anomalous=   0 #special pos.=  0 occupancies=1
 XFFT: using grid [ 125, 180, 180] and sublattice [ 125( 125), 180( 181),  60]
 XTAREXPR: ->[TEST SET]    monitor=  0.215
 XTAREXPR: ->[WORKING SET] monitor=  0.205
 --------------- cycle=     4 --------------------------------------------------
 | Etotal =117466.139 grad(E)=9.999      E(XREF)=117466.139                    |
 -------------------------------------------------------------------------------
 CNSsolve>display GAUCNS Energy MM4 
 CNSsolve>display $ener[e20.14] 
 CNSsolve> 
 CNSsolve>{GAUCNS Print rfree and r value} 
 CNSsolve>display GAUCNS rfree r 
 CNSsolve>display $full_test_r[f8.6] $full_r[f8.6] 
 CNSsolve>set display=OUTPUT end 
 CNSsolve> 
 CNSsolve> 
 CNSsolve> 
 CNSsolve> set display=&coordinate_outfile end 
 ASSFIL: file bindividual.pdb opened.
 CNSsolve> 
 CNSsolve> display REMARK coordinates from restrained individual B-factor refinement 
 CNSsolve> display REMARK refinement resolution: &low_res - &high_res A 
 CNSsolve> if ( $total_test > 0 ) then 
 NEXTCD: condition evaluated as true
 CNSsolve>   display REMARK starting r= $start_r[f6.4] free_r= $start_test_r[f6.4] 
 CNSsolve>   display REMARK final    r= $full_r[f6.4] free_r= $full_test_r[f6.4] 
 CNSsolve> else 
 CNSsolve>   display REMARK starting r= $start_r[f6.4] 
 CNSsolve>   display REMARK final    r= $full_r[f6.4] 
 CNSsolve> end if 
 CNSsolve> display REMARK B rmsd for bonded mainchain atoms= $brms_bond_1[f6.3]  target= &bsig_main 
 CNSsolve> if ( $exist_brms_bond_2 = true ) then 
 NEXTCD: condition evaluated as true
 CNSsolve>   display REMARK B rmsd for bonded sidechain atoms= $brms_bond_2[f6.3]  target= &bsig_side 
 CNSsolve> end if 
 CNSsolve> display REMARK B rmsd for angle mainchain atoms= $brms_angl_1[f6.3]  target= &asig_main 
 CNSsolve> if ( $exist_brms_angl_2 = true ) then 
 NEXTCD: condition evaluated as true
 CNSsolve>   display REMARK B rmsd for angle sidechain atoms= $brms_angl_2[f6.3]  target= &asig_side 
 CNSsolve> end if 
 CNSsolve> xray wa=? end 
 WA= 0.50761    
 CNSsolve> evaluate ($wa_print=$result) 
 EVALUATE: symbol $WA_PRINT set to   0.507612     (real)
 CNSsolve> display REMARK rweight=$b_rweight[f8.4] (with wa= $wa_print) 
 CNSsolve> display REMARK target= &STRIP%reftarget  steps= &bfactor_nstep 
 CNSsolve> display REMARK sg= &STRIP%sg a= &a b= &b c= &c alpha= &alpha beta= &beta gamma= &gamma 
 CNSsolve> 
 CNSsolve> evaluate ($counter=1) 
 EVALUATE: symbol $COUNTER set to    1.00000     (real)
 CNSsolve> evaluate ($done=false) 
 EVALUATE: symbol $DONE set to FALSE (logical)
 CNSsolve> while ( $done = false ) loop read 
 NEXTCD: condition evaluated as true
 CNSsolve>  if ( &exist_parameter_infile_$counter = true ) then 
 NEXTCD: condition evaluated as true
 CNSsolve>    if ( &BLANK%parameter_infile_$counter = false ) then 
 NEXTCD: condition evaluated as true
 CNSsolve>      display REMARK parameter file $counter  : &STRIP%parameter_infile_$counter 
 CNSsolve>    end if 
 CNSsolve>  else 
 CNSsolve>   evaluate ($done=true) 
 CNSsolve>  end if 
 CNSsolve>  evaluate ($counter=$counter+1) 
 EVALUATE: symbol $COUNTER set to    2.00000     (real)
 CNSsolve> end loop read 
 CNSsolve> while ( $done = false ) loop read 
 NEXTCD: condition evaluated as true
 CNSsolve>  if ( &exist_parameter_infile_$counter = true ) then 
 NEXTCD: condition evaluated as true
 CNSsolve>    if ( &BLANK%parameter_infile_$counter = false ) then 
 NEXTCD: condition evaluated as true
 CNSsolve>      display REMARK parameter file $counter  : &STRIP%parameter_infile_$counter 
 CNSsolve>    end if 
 CNSsolve>  else 
 CNSsolve>   evaluate ($done=true) 
 CNSsolve>  end if 
 CNSsolve>  evaluate ($counter=$counter+1) 
 EVALUATE: symbol $COUNTER set to    3.00000     (real)
 CNSsolve> end loop read 
 CNSsolve> while ( $done = false ) loop read 
 NEXTCD: condition evaluated as true
 CNSsolve>  if ( &exist_parameter_infile_$counter = true ) then 
 NEXTCD: condition evaluated as true
 CNSsolve>    if ( &BLANK%parameter_infile_$counter = false ) then 
 NEXTCD: condition evaluated as true
 CNSsolve>      display REMARK parameter file $counter  : &STRIP%parameter_infile_$counter 
 CNSsolve>    end if 
 CNSsolve>  else 
 CNSsolve>   evaluate ($done=true) 
 CNSsolve>  end if 
 CNSsolve>  evaluate ($counter=$counter+1) 
 EVALUATE: symbol $COUNTER set to    4.00000     (real)
 CNSsolve> end loop read 
 CNSsolve> while ( $done = false ) loop read 
 NEXTCD: condition evaluated as true
 CNSsolve>  if ( &exist_parameter_infile_$counter = true ) then 
 NEXTCD: condition evaluated as true
 CNSsolve>    if ( &BLANK%parameter_infile_$counter = false ) then 
 NEXTCD: condition evaluated as true
 CNSsolve>      display REMARK parameter file $counter  : &STRIP%parameter_infile_$counter 
 CNSsolve>    end if 
 CNSsolve>  else 
 CNSsolve>   evaluate ($done=true) 
 CNSsolve>  end if 
 CNSsolve>  evaluate ($counter=$counter+1) 
 EVALUATE: symbol $COUNTER set to    5.00000     (real)
 CNSsolve> end loop read 
 CNSsolve> while ( $done = false ) loop read 
 NEXTCD: condition evaluated as true
 CNSsolve>  if ( &exist_parameter_infile_$counter = true ) then 
 NEXTCD: condition evaluated as true
 CNSsolve>    if ( &BLANK%parameter_infile_$counter = false ) then 
 NEXTCD: condition evaluated as true
 CNSsolve>      display REMARK parameter file $counter  : &STRIP%parameter_infile_$counter 
 CNSsolve>    end if 
 CNSsolve>  else 
 CNSsolve>   evaluate ($done=true) 
 CNSsolve>  end if 
 CNSsolve>  evaluate ($counter=$counter+1) 
 EVALUATE: symbol $COUNTER set to    6.00000     (real)
 CNSsolve> end loop read 
 CNSsolve> while ( $done = false ) loop read 
 NEXTCD: condition evaluated as true
 CNSsolve>  if ( &exist_parameter_infile_$counter = true ) then 
 NEXTCD: condition evaluated as true
 CNSsolve>    if ( &BLANK%parameter_infile_$counter = false ) then 
 NEXTCD: condition evaluated as true
 CNSsolve>      display REMARK parameter file $counter  : &STRIP%parameter_infile_$counter 
 CNSsolve>    end if 
 CNSsolve>  else 
 CNSsolve>   evaluate ($done=true) 
 CNSsolve>  end if 
 CNSsolve>  evaluate ($counter=$counter+1) 
 EVALUATE: symbol $COUNTER set to    7.00000     (real)
 CNSsolve> end loop read 
 CNSsolve> while ( $done = false ) loop read 
 NEXTCD: condition evaluated as true
 CNSsolve>  if ( &exist_parameter_infile_$counter = true ) then 
 NEXTCD: condition evaluated as true
 CNSsolve>    if ( &BLANK%parameter_infile_$counter = false ) then 
 NEXTCD: condition evaluated as false
 CNSsolve>      display REMARK parameter file $counter  : &STRIP%parameter_infile_$counter 
 CNSsolve>    end if 
 CNSsolve>  else 
 CNSsolve>   evaluate ($done=true) 
 CNSsolve>  end if 
 CNSsolve>  evaluate ($counter=$counter+1) 
 EVALUATE: symbol $COUNTER set to    8.00000     (real)
 CNSsolve> end loop read 
 CNSsolve> while ( $done = false ) loop read 
 NEXTCD: condition evaluated as true
 CNSsolve>  if ( &exist_parameter_infile_$counter = true ) then 
 NEXTCD: condition evaluated as true
 CNSsolve>    if ( &BLANK%parameter_infile_$counter = false ) then 
 NEXTCD: condition evaluated as false
 CNSsolve>      display REMARK parameter file $counter  : &STRIP%parameter_infile_$counter 
 CNSsolve>    end if 
 CNSsolve>  else 
 CNSsolve>   evaluate ($done=true) 
 CNSsolve>  end if 
 CNSsolve>  evaluate ($counter=$counter+1) 
 EVALUATE: symbol $COUNTER set to    9.00000     (real)
 CNSsolve> end loop read 
 CNSsolve> while ( $done = false ) loop read 
 NEXTCD: condition evaluated as true
 CNSsolve>  if ( &exist_parameter_infile_$counter = true ) then 
 NEXTCD: condition evaluated as false
 CNSsolve>    if ( &BLANK%parameter_infile_$counter = false ) then 
 CNSsolve>      display REMARK parameter file $counter  : &STRIP%parameter_infile_$counter 
 CNSsolve>    end if 
 CNSsolve>  else 
 CNSsolve>   evaluate ($done=true) 
 EVALUATE: symbol $DONE set to TRUE (logical)
 CNSsolve>  end if 
 CNSsolve>  evaluate ($counter=$counter+1) 
 EVALUATE: symbol $COUNTER set to    10.0000     (real)
 CNSsolve> end loop read 
 CNSsolve> while ( $done = false ) loop read 
 NEXTCD: condition evaluated as false
 CNSsolve>  if ( &exist_parameter_infile_$counter = true ) then 
 CNSsolve>    if ( &BLANK%parameter_infile_$counter = false ) then 
 CNSsolve>      display REMARK parameter file $counter  : &STRIP%parameter_infile_$counter 
 CNSsolve>    end if 
 CNSsolve>  else 
 CNSsolve>   evaluate ($done=true) 
 CNSsolve>  end if 
 CNSsolve>  evaluate ($counter=$counter+1) 
 CNSsolve> end loop read 
 CNSsolve> 
 CNSsolve> if ( &BLANK%structure_infile = true ) then 
 NEXTCD: condition evaluated as false
 CNSsolve>   display REMARK molecular structure file: automatic 
 CNSsolve> 
 CNSsolve>   evaluate ($counter=1) 
 CNSsolve>   evaluate ($done=false) 
 CNSsolve>   while ( $done = false ) loop read 
 CNSsolve>    if ( &exist_topology_infile_$counter = true ) then 
 CNSsolve>      if ( &BLANK%topology_infile_$counter = false ) then 
 CNSsolve>        display REMARK topology file $counter  : &STRIP%topology_infile_$counter 
 CNSsolve>      end if 
 CNSsolve>    else 
 CNSsolve>     evaluate ($done=true) 
 CNSsolve>    end if 
 CNSsolve>    evaluate ($counter=$counter+1) 
 CNSsolve>   end loop read 
 CNSsolve> 
 CNSsolve>   evaluate ($counter=1) 
 CNSsolve>   evaluate ($done=false) 
 CNSsolve>   while ( $done = false ) loop read 
 CNSsolve>    if ( &exist_link_infile_$counter = true ) then 
 CNSsolve>      if ( &BLANK%link_infile_$counter = false ) then 
 CNSsolve>        display REMARK linkage file $counter  : &STRIP%link_infile_$counter 
 CNSsolve>      end if 
 CNSsolve>    else 
 CNSsolve>     evaluate ($done=true) 
 CNSsolve>    end if 
 CNSsolve>    evaluate ($counter=$counter+1) 
 CNSsolve>   end loop read 
 CNSsolve> 
 CNSsolve>   if ( &BLANK%patch_infile = false ) then 
 CNSsolve>      display REMARK custom patch file = &STRIP%patch_infile 
 CNSsolve>   end if 
 CNSsolve> 
 CNSsolve> else 
 CNSsolve>   display REMARK molecular structure file: &STRIP%structure_infile 
 CNSsolve> end if 
 CNSsolve> 
 CNSsolve> display REMARK input coordinates: &STRIP%coordinate_infile 
 CNSsolve> if ( &BLANK%anom_library = false ) then 
 NEXTCD: condition evaluated as false
 CNSsolve>   display REMARK anomalous f' f'' library: &STRIP%anom_library 
 CNSsolve> end if 
 CNSsolve> 
 CNSsolve> evaluate ($counter=1) 
 EVALUATE: symbol $COUNTER set to    1.00000     (real)
 CNSsolve> evaluate ($done=false) 
 EVALUATE: symbol $DONE set to FALSE (logical)
 CNSsolve> while ( $done = false ) loop read 
 NEXTCD: condition evaluated as true
 CNSsolve>    if ( &exist_reflection_infile_$counter = true ) then 
 NEXTCD: condition evaluated as true
 CNSsolve>      if ( &BLANK%reflection_infile_$counter = false ) then 
 NEXTCD: condition evaluated as true
 CNSsolve>         display REMARK reflection file $counter : &STRIP%reflection_infile_$counter 
 CNSsolve>      end if 
 CNSsolve>   else 
 CNSsolve>     evaluate ($done=true) 
 CNSsolve>   end if 
 CNSsolve>   evaluate ($counter=$counter+1) 
 EVALUATE: symbol $COUNTER set to    2.00000     (real)
 CNSsolve> end loop read 
 CNSsolve> while ( $done = false ) loop read 
 NEXTCD: condition evaluated as true
 CNSsolve>    if ( &exist_reflection_infile_$counter = true ) then 
 NEXTCD: condition evaluated as true
 CNSsolve>      if ( &BLANK%reflection_infile_$counter = false ) then 
 NEXTCD: condition evaluated as false
 CNSsolve>         display REMARK reflection file $counter : &STRIP%reflection_infile_$counter 
 CNSsolve>      end if 
 CNSsolve>   else 
 CNSsolve>     evaluate ($done=true) 
 CNSsolve>   end if 
 CNSsolve>   evaluate ($counter=$counter+1) 
 EVALUATE: symbol $COUNTER set to    3.00000     (real)
 CNSsolve> end loop read 
 CNSsolve> while ( $done = false ) loop read 
 NEXTCD: condition evaluated as true
 CNSsolve>    if ( &exist_reflection_infile_$counter = true ) then 
 NEXTCD: condition evaluated as true
 CNSsolve>      if ( &BLANK%reflection_infile_$counter = false ) then 
 NEXTCD: condition evaluated as false
 CNSsolve>         display REMARK reflection file $counter : &STRIP%reflection_infile_$counter 
 CNSsolve>      end if 
 CNSsolve>   else 
 CNSsolve>     evaluate ($done=true) 
 CNSsolve>   end if 
 CNSsolve>   evaluate ($counter=$counter+1) 
 EVALUATE: symbol $COUNTER set to    4.00000     (real)
 CNSsolve> end loop read 
 CNSsolve> while ( $done = false ) loop read 
 NEXTCD: condition evaluated as true
 CNSsolve>    if ( &exist_reflection_infile_$counter = true ) then 
 NEXTCD: condition evaluated as true
 CNSsolve>      if ( &BLANK%reflection_infile_$counter = false ) then 
 NEXTCD: condition evaluated as false
 CNSsolve>         display REMARK reflection file $counter : &STRIP%reflection_infile_$counter 
 CNSsolve>      end if 
 CNSsolve>   else 
 CNSsolve>     evaluate ($done=true) 
 CNSsolve>   end if 
 CNSsolve>   evaluate ($counter=$counter+1) 
 EVALUATE: symbol $COUNTER set to    5.00000     (real)
 CNSsolve> end loop read 
 CNSsolve> while ( $done = false ) loop read 
 NEXTCD: condition evaluated as true
 CNSsolve>    if ( &exist_reflection_infile_$counter = true ) then 
 NEXTCD: condition evaluated as false
 CNSsolve>      if ( &BLANK%reflection_infile_$counter = false ) then 
 CNSsolve>         display REMARK reflection file $counter : &STRIP%reflection_infile_$counter 
 CNSsolve>      end if 
 CNSsolve>   else 
 CNSsolve>     evaluate ($done=true) 
 EVALUATE: symbol $DONE set to TRUE (logical)
 CNSsolve>   end if 
 CNSsolve>   evaluate ($counter=$counter+1) 
 EVALUATE: symbol $COUNTER set to    6.00000     (real)
 CNSsolve> end loop read 
 CNSsolve> while ( $done = false ) loop read 
 NEXTCD: condition evaluated as false
 CNSsolve>    if ( &exist_reflection_infile_$counter = true ) then 
 CNSsolve>      if ( &BLANK%reflection_infile_$counter = false ) then 
 CNSsolve>         display REMARK reflection file $counter : &STRIP%reflection_infile_$counter 
 CNSsolve>      end if 
 CNSsolve>   else 
 CNSsolve>     evaluate ($done=true) 
 CNSsolve>   end if 
 CNSsolve>   evaluate ($counter=$counter+1) 
 CNSsolve> end loop read 
 CNSsolve> 
 CNSsolve> if ( &BLANK%ncs_infile = false ) then 
 NEXTCD: condition evaluated as false
 CNSsolve>   display REMARK ncs= &STRIP%ncs_type  ncs file= &STRIP%ncs_infile 
 CNSsolve> else 
 CNSsolve>   display REMARK ncs= none 
 CNSsolve> end if 
 CNSsolve> if ( &bscale # "no" ) then 
 NEXTCD: condition evaluated as true
 CNSsolve>   if ( $low_b_flag = true ) then 
 NEXTCD: condition evaluated as false
 CNSsolve>     display REMARK warning: B-correction gave atomic B-values less than zero 
 CNSsolve>     display REMARK          they have been reset to zero 
 CNSsolve>   end if 
 CNSsolve> end if 
 CNSsolve> 
 CNSsolve> ! 
 CNSsolve> ! Begin modification (6/28/06) 
 CNSsolve> if ( &bscale = "anisotropic" ) then 
 NEXTCD: condition evaluated as true
 CNSsolve>   display REMARK Anisotropic B-factor tensor Ucart of atomic model without isotropic component : 
 CNSsolve>   display REMARK   B11=$Baniso_11[f8.3] B22=$Baniso_22[f8.3] B33=$Baniso_33[f8.3] 
 CNSsolve>   display REMARK   B12=$Baniso_12[f8.3] B13=$Baniso_13[f8.3] B23=$Baniso_23[f8.3] 
 CNSsolve>   display REMARK Isotropic component added to coordinate array B: $Biso_model[f8.3] 
 CNSsolve> elseif ( &bscale = "isotropic" ) then 
 CNSsolve>   display REMARK B-factor applied to coordinate array B: $Biso_model[f8.3] 
 CNSsolve> else 
 CNSsolve>   display REMARK initial B-factor correction: none 
 CNSsolve> end if 
 CNSsolve> ! End modification 
 CNSsolve> ! 
 CNSsolve> 
 CNSsolve> {- MODIFIED 5/18/05 -} 
 CNSsolve> if ( &bulk_sol = true ) then 
 NEXTCD: condition evaluated as true
 CNSsolve>   display REMARK bulk solvent: probe radius=$solrad_best, shrink value=$solrad_best 
 CNSsolve>   display REMARK bulk solvent: density level= $sol_k_ref e/A^3, B-factor= $sol_b_ref A^2 
 CNSsolve> else 
 CNSsolve>   display REMARK bulk solvent: false 
 CNSsolve> end if 
 CNSsolve> {- END MODIFICATION -} 
 CNSsolve> 
 CNSsolve> if ( &obs_type = "intensity" ) then 
 NEXTCD: condition evaluated as false
 CNSsolve>   display REMARK reflections with Iobs/sigma_I < &sigma_cut rejected 
 CNSsolve>   display REMARK reflections with Iobs > &obs_rms * rms(Iobs) rejected 
 CNSsolve> else 
 CNSsolve>   display REMARK reflections with |Fobs|/sigma_F < &sigma_cut rejected 
 CNSsolve>   display REMARK reflections with |Fobs| > &obs_rms * rms(Fobs) rejected 
 CNSsolve> end if 
 CNSsolve> xray anomalous=? end 
 ANOMalous=FALSe {OFF}
 CNSsolve> if ( $result = true ) then 
 NEXTCD: condition evaluated as false
 CNSsolve>   display REMARK anomalous diffraction data was input 
 CNSsolve> end if 
 CNSsolve> 
 CNSsolve>  {- MODIFIED 2/15/06 -} 
 CNSsolve> display REMARK fft gridding factor = $fft_grid, B factor offset = $fft_b_add A^2, Elimit = $fft_elim 
 CNSsolve> {- END MODIFICATION -} 
 CNSsolve> 
 CNSsolve> display REMARK theoretical total number of refl. in resol. range:    $total_theor[I6] ( 100.0 % ) 
 CNSsolve> display REMARK number of unobserved reflections (no entry):          $unobserved[I6] ( $per_unobs[f5.1] % ) 
 CNSsolve> display REMARK number of reflections rejected:                       $rejected[I6] ( $per_reject[f5.1] % ) 
 CNSsolve> display REMARK total number of reflections used:                     $total_used[I6] ( $per_used[f5.1] % ) 
 CNSsolve> display REMARK number of reflections in working set:                 $total_work[I6] ( $per_work[f5.1] % ) 
 CNSsolve> display REMARK number of reflections in test set:                    $total_test[I6] ( $per_test[f5.1] % ) 
 CNSsolve> 
 CNSsolve> remark 
 CNSsolve> 
 CNSsolve> {GauCNS: Construct the set of 4th to 8th decimals in xyzcomp} 
 CNSsolve>do ( xcomp = int( x * 1000.0) / 1000.0 ) (all) 
 SELRPN:   3020 atoms have been selected out of   3020
 CNSsolve>do ( ycomp = int( y * 1000.0) / 1000.0 ) (all) 
 SELRPN:   3020 atoms have been selected out of   3020
 CNSsolve>do ( zcomp = int( z * 1000.0) / 1000.0 ) (all) 
 SELRPN:   3020 atoms have been selected out of   3020
 CNSsolve>do ( refx = (x - xcomp)*100000.0 ) (all) 
 SELRPN:   3020 atoms have been selected out of   3020
 CNSsolve>do ( refy = (y - ycomp)*100000.0 ) (all) 
 SELRPN:   3020 atoms have been selected out of   3020
 CNSsolve>do ( refz = (z - zcomp)*100000.0 ) (all) 
 SELRPN:   3020 atoms have been selected out of   3020
 CNSsolve>do ( x = xcomp ) (all) 
 SELRPN:   3020 atoms have been selected out of   3020
 CNSsolve>do ( y = ycomp ) (all) 
 SELRPN:   3020 atoms have been selected out of   3020
 CNSsolve>do ( z = zcomp ) (all) 
 SELRPN:   3020 atoms have been selected out of   3020
 CNSsolve> 
 CNSsolve> @CNS_XTALMODULE:write_pdb (pdb_o_format=true; 
 ASSFIL: file write_pdb opened.
 CNSsolve>! Module file: write_pdb 
 CNSsolve>! 
 CNSsolve>! CNS module 
 CNSsolve>! ********** 
 CNSsolve>! 
 CNSsolve>! Authors: Axel Brunger and Paul Adams 
 CNSsolve>! 
 CNSsolve>! copyright Yale University 
 CNSsolve>! 
 CNSsolve>! Function: 
 CNSsolve>!    Write out a PDB file - in CNS or O format 
 CNSsolve>!    In O format the segid will be written in the chainid 
 CNSsolve>!    column if it is one character 
 CNSsolve>! 
 CNSsolve>! Requirements: 
 CNSsolve>!    Needs to be called from main level 
 CNSsolve> 
 CNSsolve>module {write_pdb} 
 MODULE-DECLARATION> 
 MODULE-DECLARATION>( 
 MODULE-DECLARATION>  &pdb_o_format=false; 
 MODULE-DECLARATION>  &coordinate_outfile="OUTPUT"; 
 MODULE-DECLARATION>  &sgparam; 
 MODULE-DECLARATION>) 
 &_2_PDB_O_FORMAT set to true 
 MODULE-INVOCATION>                            coordinate_outfile=&coordinate_outfile; 
 &_2_COORDINATE_OUTFILE set to &_1_COORDINATE_OUTFILE 
 MODULE-INVOCATION>                            sgparam=$sgparam;) 
 &_2_SGPARAM set to $_1_SGPARAM 
 CNSsolve> 
 CNSsolve> if ( &pdb_o_format = true ) then 
 NEXTCD: condition evaluated as true
 CNSsolve> 
 CNSsolve>   @@CNS_XTALMODULE:pdbgetsgname (sg=&sgparam.sg_number; 
 ASSFIL: file pdbgetsgname opened.
 CNSsolve>! Module file: pdbsgname 
 CNSsolve>! 
 CNSsolve>! CNS module 
 CNSsolve>! ********** 
 CNSsolve>! 
 CNSsolve>! Authors: Jian-Sheng Jiang and Axel T. Brunger 
 CNSsolve>! 
 CNSsolve>! copyright Yale University 
 CNSsolve>! 
 CNSsolve>! Function: 
 CNSsolve>! Get the space group name in PDB's convention for a given number 
 CNSsolve>! Return the name in "&sgname" 
 CNSsolve>! 
 CNSsolve>! Requirements: 
 CNSsolve>!{ The name of space group in the PDB's convention           } 
 CNSsolve>!{    (1) a string limits to 11 columns                      } 
 CNSsolve>!{    (2) symmetry directions separate by a white-space      } 
 CNSsolve>!{    (3) the screw rotation axes use a number with 2 digits } 
 CNSsolve>!{    (4) inversion rotation axes with the minus sign "-"    } 
 CNSsolve>!{    (5) perpendicular indicator "/" is allowed             } 
 CNSsolve>!{    Examples: "P 21/C", "P 42/N B C","R -3","F 4 -3 M"     } 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>module { pdbgetsgname } 
 MODULE-DECLARATION>( 
 MODULE-DECLARATION>   &sg=0;              { the number of the space group for input  } 
 MODULE-DECLARATION>   &sgname=" ";        { the name of the space group for return   } 
 MODULE-DECLARATION>) 
 &_3_SG set to &_2_SGPARAM.SG_NUMBER 
 MODULE-INVOCATION>                                  sgname=$sg_pdb;) 
 &_3_SGNAME set to $_2_SG_PDB 
 CNSsolve> 
 CNSsolve>  set message ? end 
 MESSage=NORM
 CNSsolve>  evaluate ($message_old=$result) 
 EVALUATE: symbol $MESSAGE_OLD set to "NORM" (string)
 CNSsolve>  set echo ? end 
 ECHO=TRUE {ON}
 CNSsolve>  evaluate ($echo_old=$result) 
 EVALUATE: symbol $ECHO_OLD set to TRUE (logical)
 CNSsolve>  if ( $log_level = verbose ) then 
 NEXTCD: condition evaluated as false
 CNSsolve>    set echo=on message=normal end 
 CNSsolve>  else 
 CNSsolve>    set echo=off message=off end 
 CNSsolve> 
 CNSsolve>   set display=? end 
 DISPlay-file=bindividual.pdb
 CNSsolve>   evaluate ($curr_display=$result) 
 EVALUATE: symbol $CURR_DISPLAY set to "bindividual.pdb" (string)
 CNSsolve> 
 CNSsolve>   set display=&coordinate_outfile end 
 CNSsolve> 
 CNSsolve>   display CRYST1 $xrcell_1[f8.3] $xrcell_2[f8.3] $xrcell_3[f8.3] \ 
  $xrcell_4[f6.2] $xrcell_5[f6.2] $xrcell_6[f6.2] $sg_pdb[a10] 
 CNSsolve> 
 CNSsolve>   set display=$curr_display end 
 CNSsolve> 
 CNSsolve>   write coordinates 
 WRITE-COOR>     {- modification: only known coordinates ATB 11/25/08 -} 
 WRITE-COOR>     format=PDBO output=&coordinate_outfile selection=( known ) 
 SELRPN:   3020 atoms have been selected out of   3020
 WRITE-COOR>   end 
 VCLOSE: Display file reset to OUTPUT.
 CNSsolve> 
 CNSsolve> else 
 CNSsolve> 
 CNSsolve>   write coordinates 
 CNSsolve>     {- modification: only known coordinates ATB 11/25/08 -} 
 CNSsolve>     output=&coordinate_outfile selection=( known ) 
 CNSsolve>   end 
 CNSsolve> 
 CNSsolve> end if 
 CNSsolve> 
 CNSsolve>! modification ATB 5/29/08 
 CNSsolve>! close &coordinate_outfile disp=keep end 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>{GAUCNS: Write file bindividual.pdb1 only if R is improved} 
 CNSsolve>if ( $start_r > $full_r ) then 
 NEXTCD: condition evaluated as false
 CNSsolve>   do ( x = refx ) (all) 
 CNSsolve>   do ( y = refy ) (all) 
 CNSsolve>   do ( z = refz ) (all) 
 CNSsolve> 
 CNSsolve>    @CNS_XTALMODULE:write_pdb (pdb_o_format=&pdb_o_format; 
 ASSFIL: file write_pdb opened.
 CNSsolve>! Module file: write_pdb 
 CNSsolve>! 
 CNSsolve>! CNS module 
 CNSsolve>! ********** 
 CNSsolve>! 
 CNSsolve>! Authors: Axel Brunger and Paul Adams 
 CNSsolve>! 
 CNSsolve>! copyright Yale University 
 CNSsolve>! 
 CNSsolve>! Function: 
 CNSsolve>!    Write out a PDB file - in CNS or O format 
 CNSsolve>!    In O format the segid will be written in the chainid 
 CNSsolve>!    column if it is one character 
 CNSsolve>! 
 CNSsolve>! Requirements: 
 CNSsolve>!    Needs to be called from main level 
 CNSsolve> 
 CNSsolve>module {write_pdb} 
 MODULE-DECLARATION> 
 MODULE-DECLARATION>( 
 MODULE-DECLARATION>  &pdb_o_format=false; 
 MODULE-DECLARATION>  &coordinate_outfile="OUTPUT"; 
 MODULE-DECLARATION>  &sgparam; 
 MODULE-DECLARATION>) 
 MODULE-INVOCATION>                            coordinate_outfile=bindividual.pdb1; 
 MODULE-INVOCATION>                            sgparam=$sgparam;) 
 CNSsolve> 
 CNSsolve> if ( &pdb_o_format = true ) then 
 CNSsolve> 
 CNSsolve>   @@CNS_XTALMODULE:pdbgetsgname (sg=&sgparam.sg_number; 
 CNSsolve>                                  sgname=$sg_pdb;) 
 CNSsolve> 
 CNSsolve>   set display=? end 
 CNSsolve>   evaluate ($curr_display=$result) 
 CNSsolve> 
 CNSsolve>   set display=&coordinate_outfile end 
 CNSsolve> 
 CNSsolve>   display CRYST1 $xrcell_1[f8.3] $xrcell_2[f8.3] $xrcell_3[f8.3] \ 
  $xrcell_4[f6.2] $xrcell_5[f6.2] $xrcell_6[f6.2] $sg_pdb[a10] 
 CNSsolve> 
 CNSsolve>   set display=$curr_display end 
 CNSsolve> 
 CNSsolve>   write coordinates 
 CNSsolve>     {- modification: only known coordinates ATB 11/25/08 -} 
 CNSsolve>     format=PDBO output=&coordinate_outfile selection=( known ) 
 CNSsolve>   end 
 CNSsolve> 
 CNSsolve> else 
 CNSsolve> 
 CNSsolve>   write coordinates 
 CNSsolve>     {- modification: only known coordinates ATB 11/25/08 -} 
 CNSsolve>     output=&coordinate_outfile selection=( known ) 
 CNSsolve>   end 
 CNSsolve> 
 CNSsolve> end if 
 CNSsolve> 
 CNSsolve>! modification ATB 5/29/08 
 CNSsolve>! close &coordinate_outfile disp=keep end 
 CNSsolve> 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve> stop 
          ============================================================
           Maximum dynamic memory allocation:    69968736 bytes
           Maximum dynamic memory overhead:          1360 bytes
           Program started at: 20:41:25 on 19-Dec-2023
           Program stopped at: 20:41:41 on 19-Dec-2023
           CPU time used:      15.7345 seconds
          ============================================================
